#!/usr/bin/env zsh

# Clean up git worktrees with interactive selection
# Usage: worktree-cleanup

local project workspace_dir worktrees_to_remove selected_items

# Check if we're in a git repository
if git rev-parse --git-dir >/dev/null 2>&1; then
    project=$(basename $(git rev-parse --show-toplevel))
    workspace_dir="$HOME/Workspaces/$project"
    ui_action "ðŸ§¹ Cleaning up worktrees for project: $project"
else
    ui_error "Must be run from within a git repository"
    return 1
fi

# First, prune stale references
ui_spin "Pruning stale worktree references..." \
    git worktree prune

# Find all worktrees for this project
if [[ ! -d "$workspace_dir" ]]; then
    ui_success "No worktrees to clean up"
    return 0
fi

# Collect worktree information
worktrees_info=()
while IFS= read -r line; do
    if [[ -n "$line" ]]; then
        worktree_path=$(echo "$line" | sed 's|/.git||')
        if [[ -d "$worktree_path" ]]; then
            branch_name=$(basename "$worktree_path")
            # Check if branch still exists
            if git show-ref --verify --quiet "refs/heads/$branch_name" || \
               git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
                status="active"
            else
                status="stale"
            fi
            
            # Get last activity
            last_activity=$(stat -c %Y "$worktree_path" 2>/dev/null || echo "0")
            last_activity_date=$(date -d "@$last_activity" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "unknown")
            
            worktrees_info+=("$branch_name [$status] (last: $last_activity_date)|$worktree_path")
        fi
    fi
done < <(find "$workspace_dir" -name ".git" -type f -o -name ".git" -type d 2>/dev/null)

if [[ ${#worktrees_info[@]} -eq 0 ]]; then
    ui_success "No worktrees to clean up"
    return 0
fi

# Show current worktrees
ui_info "Current worktrees:" --before 1
printf '%s\n' "${worktrees_info[@]}" | cut -d'|' -f1

ui_warning "Select worktrees to remove (be careful!):" --before 1

# Let user select worktrees to remove
selected_items=$(printf '%s\n' "${worktrees_info[@]}" | \
    ui_choose_multi "" 0 | cut -d'|' -f2)

if [[ -z "$selected_items" ]]; then
    ui_info "No worktrees selected for removal"
    return 0
fi

# Confirm removal
ui_warning "You are about to remove these worktrees:" --before 1
ui_output "$selected_items" --before 1 --after 1

if ! ui_confirm "Are you sure you want to remove these worktrees?"; then
    ui_info "Operation cancelled"
    return 0
fi

# Remove selected worktrees
echo "$selected_items" | while IFS= read -r worktree_path; do
    if [[ -n "$worktree_path" ]]; then
        branch_name=$(basename "$worktree_path")
        
        # Clean up mise trust for this directory if mise is available
        if command -v mise >/dev/null 2>&1 && [[ -d "$worktree_path" ]]; then
            ui_spin "Cleaning up mise trust for '$branch_name'..." \
                "cd '$worktree_path' && mise trust --untrust 2>/dev/null || true"
        fi
        
        ui_spin "Removing worktree '$branch_name'..." \
            git worktree remove "$worktree_path" --force
        
        if [[ $? -eq 0 ]]; then
            ui_success "Removed worktree: $branch_name"
        else
            ui_error "Failed to remove worktree: $branch_name"
        fi
    fi
done

# Clean up empty directories
if [[ -d "$workspace_dir" ]] && [[ -z "$(ls -A "$workspace_dir" 2>/dev/null)" ]]; then
    rmdir "$workspace_dir" 2>/dev/null
    ui_info "Removed empty workspace directory"
fi

ui_complete "Cleanup completed" --before 1