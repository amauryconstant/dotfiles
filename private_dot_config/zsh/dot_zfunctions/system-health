#!/bin/zsh

# System Health Dashboard
# Purpose: Comprehensive system status overview with interactive UI
# Requirements: Arch Linux, gum, glances, inxi, lm_sensors, pacman-contrib

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Interactive system health dashboard - assumes gum is available

# Print section header
print_section() {
    gum style --foreground "#00aaff" --bold --border double --padding "1 2" --margin "1 0" "$1"
}

# Print status with color
print_status() {
    local status_type="$1"
    local message="$2"
    
    case "$status_type" in
        "OK"|"GOOD")
            gum style --foreground "#00ff00" "âœ“ $message"
            ;;
        "WARN"|"WARNING")
            gum style --foreground "#ffaa00" "âš  $message"
            ;;
        "ERROR"|"CRITICAL")
            gum style --foreground "#ff0000" --bold "âœ— $message"
            ;;
        "INFO")
            gum style --foreground "#00aaff" "â„¹ $message"
            ;;
        *)
            echo "  $message"
            ;;
    esac
}

# Interactive mode selection if gum is available and no arguments provided
BRIEF=false
FULL=false
SERVICES=false
PACKAGES=false
HARDWARE=false
NETWORK=false

# Handle help flag
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    gum style --foreground "#00aaff" --bold "System Health Dashboard"
    echo ""
    gum style --foreground "#ffaa00" "Interactive mode (default):"
    echo "  Run without arguments to use interactive menus"
    echo ""
    gum style --foreground "#ffaa00" "Command line options:"
    echo "  --brief      Show brief system overview"
    echo "  --full       Show comprehensive system information"
    echo "  --services   Show only service status"
    echo "  --packages   Show only package information"
    echo "  --hardware   Show only hardware information"
    echo "  --network    Show only network status"
    echo "  --help, -h   Show this help message"
    return 0
fi

# Parse command line arguments (maintain backward compatibility)
while [[ $# -gt 0 ]]; do
    case $1 in
        --brief)
            BRIEF=true
            shift
            ;;
        --full)
            FULL=true
            shift
            ;;
        --services)
            SERVICES=true
            shift
            ;;
        --packages)
            PACKAGES=true
            shift
            ;;
        --hardware)
            HARDWARE=true
            shift
            ;;
        --network)
            NETWORK=true
            shift
            ;;
        *)
            gum style --foreground "#ff0000" "Unknown option: $1"
            gum style --foreground "#00aaff" "Use --help for usage information"
            return 1
            ;;
    esac
done

# Interactive mode selection if no arguments provided
if [[ $# -eq 0 ]]; then
    MODE=$(gum choose --header "Select system health check mode:" \
        "ðŸ“Š Standard Dashboard (All Sections)" \
        "âš¡ Brief Overview" \
        "ðŸ” Comprehensive Report" \
        "âš™ï¸  Services Only" \
        "ðŸ“¦ Packages Only" \
        "ðŸ”§ Hardware Only" \
        "ðŸŒ Network Only")
    
    case "$MODE" in
        "ðŸ“Š Standard Dashboard (All Sections)")
            SERVICES=true
            PACKAGES=true
            HARDWARE=true
            NETWORK=true
            ;;
        "âš¡ Brief Overview")
            BRIEF=true
            ;;
        "ðŸ” Comprehensive Report")
            FULL=true
            ;;
        "âš™ï¸  Services Only")
            SERVICES=true
            ;;
        "ðŸ“¦ Packages Only")
            PACKAGES=true
            ;;
        "ðŸ”§ Hardware Only")
            HARDWARE=true
            ;;
        "ðŸŒ Network Only")
            NETWORK=true
            ;;
        *)
            # User cancelled, exit gracefully
            gum style --foreground "#ffaa00" "Operation cancelled"
            return 0
            ;;
    esac
fi

# System Overview (always shown unless --brief or specific sections)
if [[ "$BRIEF" == false && "$SERVICES" == false && "$PACKAGES" == false && "$HARDWARE" == false && "$NETWORK" == false ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸ–¥ï¸  SYSTEM OVERVIEW"
    
    if command_exists fastfetch; then
        fastfetch --config none --structure "Title:Separator:OS:Host:Kernel:Uptime:Packages:Shell:Display:DE:WM:WMTheme:Theme:Icons:Font:Cursor:Terminal:TerminalFont:CPU:GPU:Memory:Disk:LocalIP:Battery:PowerAdapter:Locale:Break:Colors"
    else
        print_status "WARN" "fastfetch not available - install for better system overview"
        echo "System: $(uname -sr)"
        echo "Hostname: $(hostname)"
        echo "Uptime: $(uptime -p 2>/dev/null || uptime)"
    fi
fi

# Brief mode - just essential info
if [[ "$BRIEF" == true ]]; then
    print_section "ðŸ“Š BRIEF SYSTEM STATUS"
    
    # Load average
    load_avg=$(uptime | awk -F'load average:' '{print $2}' | xargs)
    print_status "INFO" "Load Average: $load_avg"
    
    # Memory usage
    memory_info=$(free -h | awk '/^Mem:/ {printf "Memory: %s used / %s total (%.1f%%)", $3, $2, ($3/$2)*100}')
    print_status "INFO" "$memory_info"
    
    # Disk usage for root
    disk_usage=$(df -h / | awk 'NR==2 {printf "Disk /: %s used / %s total (%s)", $3, $2, $5}')
    print_status "INFO" "$disk_usage"
    
    # Failed services count
    failed_services=$(systemctl list-units --type=service --state=failed --no-legend 2>/dev/null | wc -l)
    if [[ $failed_services -eq 0 ]]; then
        print_status "OK" "All services running normally"
    else
        print_status "WARN" "$failed_services failed service(s)"
    fi
    
    return 0
fi

# Resource Usage
if [[ "$SERVICES" == false && "$PACKAGES" == false && "$HARDWARE" == false && "$NETWORK" == false ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸ“Š RESOURCE USAGE"
    
    # CPU and Memory usage
    if command_exists glances; then
        echo -e "${CYAN}Real-time resource usage (5 second snapshot):${NC}"
        timeout 5s glances --time 1 --export stdout 2>/dev/null | head -20 || {
            print_status "WARN" "glances timeout or not available"
            
            # Fallback to basic commands
            echo "Load Average: $(uptime | awk -F'load average:' '{print $2}')"
            echo ""
            free -h
            echo ""
            df -h
        }
    else
        print_status "INFO" "glances not available - showing basic resource info"
        echo ""
        free -h
        echo ""
        df -h
    fi
    
    # Temperature monitoring
    if command_exists sensors; then
        echo -e "\n${CYAN}System Temperatures:${NC}"
        sensors 2>/dev/null | grep -E "Core|Package|temp" | head -10 || print_status "INFO" "No temperature sensors detected"
    fi
fi

# Service Status
if [[ "$SERVICES" == true ]] || [[ "$FULL" == true ]]; then
    print_section "âš™ï¸  SERVICE STATUS"
    
    # Failed services
    failed_services=$(systemctl list-units --type=service --state=failed --no-legend 2>/dev/null)
    if [[ -z "$failed_services" ]]; then
        print_status "OK" "All services running normally"
    else
        print_status "ERROR" "Failed services detected:"
        echo "$failed_services" | while read -r line; do
            service_name=$(echo "$line" | awk '{print $1}')
            print_status "ERROR" "  $service_name"
        done
    fi
    
    # Key services status
    gum style --foreground "#00aaff" "Key Services Status:"
    echo ""
    
    # Create table for service status
    echo "Service|Status|State" > /tmp/services_table.txt
    key_services=("docker" "NetworkManager" "bluetooth" "cups" "sshd")
    
    for service in "${key_services[@]}"; do
        if systemctl is-active --quiet "$service" 2>/dev/null; then
            echo "$service|âœ… Active|Running" >> /tmp/services_table.txt
        elif systemctl list-unit-files --type=service | grep -q "^$service.service"; then
            echo "$service|âš ï¸  Inactive|Installed" >> /tmp/services_table.txt
        else
            echo "$service|â„¹ï¸  Not Found|Not Installed" >> /tmp/services_table.txt
        fi
    done
    
    gum table < /tmp/services_table.txt
    rm -f /tmp/services_table.txt
fi

# Package Information
if [[ "$PACKAGES" == true ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸ“¦ PACKAGE INFORMATION"
    
    # Installed packages count
    total_packages=$(pacman -Q 2>/dev/null | wc -l)
    explicit_packages=$(pacman -Qe 2>/dev/null | wc -l)
    
    print_status "INFO" "Total packages: $total_packages (${explicit_packages} explicitly installed)"
    
    # Check for updates
    if command_exists checkupdates; then
        gum style --foreground "#00aaff" "Checking for updates..."
        updates=$(gum spin --spinner dot --title "Checking package updates..." -- checkupdates 2>/dev/null)
        update_count=$(echo "$updates" | wc -l)
        
        if [[ -n "$updates" && "$updates" != "" ]]; then
            print_status "WARN" "$update_count package update(s) available"
            if [[ "$FULL" == true ]]; then
                # Use gum table for better package update display
                echo ""
                gum style --foreground "#ffaa00" --bold "Available Updates:"
                echo "Package|Current|New" > /tmp/updates_table.txt
                echo "$updates" | head -10 | awk '{print $1"|"$2"|"$4}' >> /tmp/updates_table.txt
                gum table < /tmp/updates_table.txt
                rm -f /tmp/updates_table.txt
                if [[ $update_count -gt 10 ]]; then
                    gum style --foreground "#666666" --italic "... and $((update_count - 10)) more"
                fi
            fi
        else
            print_status "OK" "System is up to date"
        fi
    else
        print_status "INFO" "checkupdates not available - install pacman-contrib for update checking"
    fi
    
    # AUR updates (if yay is available)
    if command_exists yay; then
        aur_updates=$(gum spin --spinner dot --title "Checking AUR updates..." -- sh -c "yay -Qua 2>/dev/null | wc -l")
        if [[ $aur_updates -gt 0 ]]; then
            print_status "WARN" "$aur_updates AUR package update(s) available"
        else
            print_status "OK" "AUR packages are up to date"
        fi
    fi
    
    # Orphaned packages
    orphans=$(pacman -Qtdq 2>/dev/null | wc -l)
    if [[ $orphans -gt 0 ]]; then
        print_status "WARN" "$orphans orphaned package(s) found (use: pacman -Qtdq | sudo pacman -Rns -)"
    else
        print_status "OK" "No orphaned packages"
    fi
fi

# Hardware Information
if [[ "$HARDWARE" == true ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸ”§ HARDWARE INFORMATION"
    
    if command_exists inxi; then
        echo -e "${CYAN}System Hardware Overview:${NC}"
        inxi -b 2>/dev/null || print_status "WARN" "inxi command failed"
        
        if [[ "$FULL" == true ]]; then
            echo -e "\n${CYAN}Detailed Hardware Information:${NC}"
            inxi -Fxz 2>/dev/null | head -50
        fi
    else
        print_status "INFO" "inxi not available - showing basic hardware info"
        echo "CPU: $(lscpu | grep 'Model name' | cut -d: -f2 | xargs)"
        echo "Memory: $(free -h | awk '/^Mem:/ {print $2}')"
        echo "Architecture: $(uname -m)"
    fi
    
    # Disk health (basic check)
    echo -e "\n${CYAN}Storage Devices:${NC}"
    lsblk -f 2>/dev/null | grep -E "(NAME|sd|nvme)" || print_status "INFO" "Storage information unavailable"
fi

# Network Status
if [[ "$NETWORK" == true ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸŒ NETWORK STATUS"
    
    # Network interfaces
    gum style --foreground "#00aaff" "Network Interfaces:"
    ip -br addr show 2>/dev/null | grep -v "lo.*127.0.0.1" | while read -r line; do
        interface=$(echo "$line" | awk '{print $1}')
        interface_status=$(echo "$line" | awk '{print $2}')
        ip_addr=$(echo "$line" | awk '{print $3}' | cut -d'/' -f1)
        
        if [[ "$interface_status" == "UP" ]]; then
            print_status "OK" "$interface: $ip_addr"
        else
            print_status "INFO" "$interface: $interface_status"
        fi
    done
    
    # Internet connectivity
    gum style --foreground "#00aaff" "Connectivity Test:"
    if gum spin --spinner dot --title "Testing internet connectivity..." -- ping -c 1 -W 2 8.8.8.8 >/dev/null 2>&1; then
        print_status "OK" "Internet connectivity: Available"
    else
        print_status "WARN" "Internet connectivity: Limited or unavailable"
    fi
    
    # DNS resolution test
    if gum spin --spinner dot --title "Testing DNS resolution..." -- nslookup google.com >/dev/null 2>&1; then
        print_status "OK" "DNS resolution: Working"
    else
        print_status "WARN" "DNS resolution: Issues detected"
    fi
    
    # Active connections (if requested in full mode)
    if [[ "$FULL" == true ]]; then
        echo -e "\n${CYAN}Active Network Connections:${NC}"
        ss -tuln 2>/dev/null | head -10 || print_status "INFO" "Network connection info unavailable"
    fi
fi

# System Summary
if [[ "$BRIEF" == false && "$SERVICES" == false && "$PACKAGES" == false && "$HARDWARE" == false && "$NETWORK" == false ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸ“‹ SYSTEM SUMMARY"
    
    # Last update check
    if [[ -f /var/log/pacman.log ]]; then
        last_update=$(grep -E "starting full system upgrade|synchronizing package lists" /var/log/pacman.log 2>/dev/null | tail -1 | awk '{print $1, $2}')
        if [[ -n "$last_update" ]]; then
            print_status "INFO" "Last system update: $last_update"
        fi
    fi
    
    # System load status
    load_1min=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $1}' | xargs)
    cpu_cores=$(nproc)
    
    if (( $(echo "$load_1min > $cpu_cores" | bc -l 2>/dev/null || echo 0) )); then
        print_status "WARN" "System load is high: $load_1min (cores: $cpu_cores)"
    else
        print_status "OK" "System load is normal: $load_1min (cores: $cpu_cores)"
    fi
    
    # Disk space warning
    disk_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    if [[ $disk_usage -gt 90 ]]; then
        print_status "ERROR" "Root filesystem is ${disk_usage}% full"
    elif [[ $disk_usage -gt 80 ]]; then
        print_status "WARN" "Root filesystem is ${disk_usage}% full"
    else
        print_status "OK" "Disk space is adequate (${disk_usage}% used)"
    fi
    
    echo ""
    gum style --foreground "#00ff00" --bold "âœ… System health check completed!"
    gum style --foreground "#00aaff" "Run 'system-health --help' for more options, or just 'system-health' for interactive mode."
fi