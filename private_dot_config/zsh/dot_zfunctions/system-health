#!/bin/zsh

# System Health Dashboard
# Purpose: Comprehensive system status overview with interactive UI
# Requirements: Arch Linux, gum, glances, inxi, lm_sensors, pacman-contrib

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check if gum is available for enhanced UI
HAS_GUM=false
if command_exists gum; then
    HAS_GUM=true
fi

# Print section header
print_section() {
    if [[ "$HAS_GUM" == true ]]; then
        gum style --foreground "#00aaff" --bold --border double --padding "1 2" --margin "1 0" "$1"
    else
        echo -e "\n\033[0;34m===============================================================================\033[0m"
        echo -e "\033[1;37m$1\033[0m"
        echo -e "\033[0;34m===============================================================================\033[0m"
    fi
}

# Print status with color
print_status() {
    local status_type="$1"
    local message="$2"
    
    if [[ "$HAS_GUM" == true ]]; then
        case "$status_type" in
            "OK"|"GOOD")
                gum style --foreground "#00ff00" "âœ“ $message"
                ;;
            "WARN"|"WARNING")
                gum style --foreground "#ffaa00" "âš  $message"
                ;;
            "ERROR"|"CRITICAL")
                gum style --foreground "#ff0000" --bold "âœ— $message"
                ;;
            "INFO")
                gum style --foreground "#00aaff" "â„¹ $message"
                ;;
            *)
                echo "  $message"
                ;;
        esac
    else
        # Fallback to ANSI colors
        case "$status_type" in
            "OK"|"GOOD")
                echo -e "\033[0;32mâœ“\033[0m $message"
                ;;
            "WARN"|"WARNING")
                echo -e "\033[1;33mâš \033[0m $message"
                ;;
            "ERROR"|"CRITICAL")
                echo -e "\033[0;31mâœ—\033[0m $message"
                ;;
            "INFO")
                echo -e "\033[0;36mâ„¹\033[0m $message"
                ;;
            *)
                echo "  $message"
                ;;
        esac
    fi
}

# Interactive mode selection if gum is available and no arguments provided
BRIEF=false
FULL=false
SERVICES=false
PACKAGES=false
HARDWARE=false
NETWORK=false

# Handle help flag
if [[ "$1" == "--help" || "$1" == "-h" ]]; then
    if [[ "$HAS_GUM" == true ]]; then
        gum style --foreground "#00aaff" --bold "System Health Dashboard"
        echo ""
        gum style --foreground "#ffaa00" "Interactive mode (default):"
        echo "  Run without arguments to use interactive menus"
        echo ""
        gum style --foreground "#ffaa00" "Command line options:"
        echo "  --brief      Show brief system overview"
        echo "  --full       Show comprehensive system information"
        echo "  --services   Show only service status"
        echo "  --packages   Show only package information"
        echo "  --hardware   Show only hardware information"
        echo "  --network    Show only network status"
        echo "  --help, -h   Show this help message"
    else
        echo "System Health Dashboard"
        echo ""
        echo "Usage: system-health [OPTIONS]"
        echo ""
        echo "Options:"
        echo "  --brief      Show brief system overview"
        echo "  --full       Show comprehensive system information"
        echo "  --services   Show only service status"
        echo "  --packages   Show only package information"
        echo "  --hardware   Show only hardware information"
        echo "  --network    Show only network status"
        echo "  --help, -h   Show this help message"
        echo ""
        echo "Default: Show standard dashboard (all sections)"
    fi
    return 0
fi

# Parse command line arguments (maintain backward compatibility)
while [[ $# -gt 0 ]]; do
    case $1 in
        --brief)
            BRIEF=true
            shift
            ;;
        --full)
            FULL=true
            shift
            ;;
        --services)
            SERVICES=true
            shift
            ;;
        --packages)
            PACKAGES=true
            shift
            ;;
        --hardware)
            HARDWARE=true
            shift
            ;;
        --network)
            NETWORK=true
            shift
            ;;
        *)
            if [[ "$HAS_GUM" == true ]]; then
                gum style --foreground "#ff0000" "Unknown option: $1"
                gum style --foreground "#00aaff" "Use --help for usage information"
            else
                echo "Unknown option: $1"
                echo "Use --help for usage information"
            fi
            return 1
            ;;
    esac
done

# Interactive mode selection if no arguments provided and gum is available
if [[ $# -eq 0 && "$HAS_GUM" == true ]]; then
    MODE=$(gum choose --header "Select system health check mode:" \
        "ðŸ“Š Standard Dashboard (All Sections)" \
        "âš¡ Brief Overview" \
        "ðŸ” Comprehensive Report" \
        "âš™ï¸  Services Only" \
        "ðŸ“¦ Packages Only" \
        "ðŸ”§ Hardware Only" \
        "ðŸŒ Network Only")
    
    case "$MODE" in
        "ðŸ“Š Standard Dashboard (All Sections)")
            SERVICES=true
            PACKAGES=true
            HARDWARE=true
            NETWORK=true
            ;;
        "âš¡ Brief Overview")
            BRIEF=true
            ;;
        "ðŸ” Comprehensive Report")
            FULL=true
            ;;
        "âš™ï¸  Services Only")
            SERVICES=true
            ;;
        "ðŸ“¦ Packages Only")
            PACKAGES=true
            ;;
        "ðŸ”§ Hardware Only")
            HARDWARE=true
            ;;
        "ðŸŒ Network Only")
            NETWORK=true
            ;;
        *)
            # User cancelled, exit gracefully
            if [[ "$HAS_GUM" == true ]]; then
                gum style --foreground "#ffaa00" "Operation cancelled"
            fi
            return 0
            ;;
    esac
elif [[ $# -eq 0 ]]; then
    # Default behavior when gum is not available and no arguments
    SERVICES=true
    PACKAGES=true
    HARDWARE=true
    NETWORK=true
fi

# System Overview (always shown unless --brief or specific sections)
if [[ "$BRIEF" == false && "$SERVICES" == false && "$PACKAGES" == false && "$HARDWARE" == false && "$NETWORK" == false ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸ–¥ï¸  SYSTEM OVERVIEW"
    
    if command_exists fastfetch; then
        fastfetch --config none --structure "Title:Separator:OS:Host:Kernel:Uptime:Packages:Shell:Display:DE:WM:WMTheme:Theme:Icons:Font:Cursor:Terminal:TerminalFont:CPU:GPU:Memory:Disk:LocalIP:Battery:PowerAdapter:Locale:Break:Colors"
    else
        print_status "WARN" "fastfetch not available - install for better system overview"
        echo "System: $(uname -sr)"
        echo "Hostname: $(hostname)"
        echo "Uptime: $(uptime -p 2>/dev/null || uptime)"
    fi
fi

# Brief mode - just essential info
if [[ "$BRIEF" == true ]]; then
    print_section "ðŸ“Š BRIEF SYSTEM STATUS"
    
    # Load average
    load_avg=$(uptime | awk -F'load average:' '{print $2}' | xargs)
    print_status "INFO" "Load Average: $load_avg"
    
    # Memory usage
    memory_info=$(free -h | awk '/^Mem:/ {printf "Memory: %s used / %s total (%.1f%%)", $3, $2, ($3/$2)*100}')
    print_status "INFO" "$memory_info"
    
    # Disk usage for root
    disk_usage=$(df -h / | awk 'NR==2 {printf "Disk /: %s used / %s total (%s)", $3, $2, $5}')
    print_status "INFO" "$disk_usage"
    
    # Failed services count
    failed_services=$(systemctl list-units --type=service --state=failed --no-legend 2>/dev/null | wc -l)
    if [[ $failed_services -eq 0 ]]; then
        print_status "OK" "All services running normally"
    else
        print_status "WARN" "$failed_services failed service(s)"
    fi
    
    return 0
fi

# Resource Usage
if [[ "$SERVICES" == false && "$PACKAGES" == false && "$HARDWARE" == false && "$NETWORK" == false ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸ“Š RESOURCE USAGE"
    
    # CPU and Memory usage
    if command_exists glances; then
        echo -e "${CYAN}Real-time resource usage (5 second snapshot):${NC}"
        timeout 5s glances --time 1 --export stdout 2>/dev/null | head -20 || {
            print_status "WARN" "glances timeout or not available"
            
            # Fallback to basic commands
            echo "Load Average: $(uptime | awk -F'load average:' '{print $2}')"
            echo ""
            free -h
            echo ""
            df -h
        }
    else
        print_status "INFO" "glances not available - showing basic resource info"
        echo ""
        free -h
        echo ""
        df -h
    fi
    
    # Temperature monitoring
    if command_exists sensors; then
        echo -e "\n${CYAN}System Temperatures:${NC}"
        sensors 2>/dev/null | grep -E "Core|Package|temp" | head -10 || print_status "INFO" "No temperature sensors detected"
    fi
fi

# Service Status
if [[ "$SERVICES" == true ]] || [[ "$FULL" == true ]]; then
    print_section "âš™ï¸  SERVICE STATUS"
    
    # Failed services
    failed_services=$(systemctl list-units --type=service --state=failed --no-legend 2>/dev/null)
    if [[ -z "$failed_services" ]]; then
        print_status "OK" "All services running normally"
    else
        print_status "ERROR" "Failed services detected:"
        echo "$failed_services" | while read -r line; do
            service_name=$(echo "$line" | awk '{print $1}')
            print_status "ERROR" "  $service_name"
        done
    fi
    
    # Key services status
    if [[ "$HAS_GUM" == true ]]; then
        gum style --foreground "#00aaff" "Key Services Status:"
        echo ""
        
        # Create table for service status
        echo "Service|Status|State" > /tmp/services_table.txt
        key_services=("docker" "NetworkManager" "bluetooth" "cups" "sshd")
        
        for service in "${key_services[@]}"; do
            if systemctl is-active --quiet "$service" 2>/dev/null; then
                echo "$service|âœ… Active|Running" >> /tmp/services_table.txt
            elif systemctl list-unit-files --type=service | grep -q "^$service.service"; then
                echo "$service|âš ï¸  Inactive|Installed" >> /tmp/services_table.txt
            else
                echo "$service|â„¹ï¸  Not Found|Not Installed" >> /tmp/services_table.txt
            fi
        done
        
        gum table < /tmp/services_table.txt
        rm -f /tmp/services_table.txt
    else
        echo -e "\n\033[0;36mKey Services Status:\033[0m"
        key_services=("docker" "NetworkManager" "bluetooth" "cups" "sshd")
        
        for service in "${key_services[@]}"; do
            if systemctl is-active --quiet "$service" 2>/dev/null; then
                print_status "OK" "$service: running"
            elif systemctl list-unit-files --type=service | grep -q "^$service.service"; then
                print_status "WARN" "$service: not running (but installed)"
            else
                print_status "INFO" "$service: not installed"
            fi
        done
    fi
fi

# Package Information
if [[ "$PACKAGES" == true ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸ“¦ PACKAGE INFORMATION"
    
    # Installed packages count
    total_packages=$(pacman -Q 2>/dev/null | wc -l)
    explicit_packages=$(pacman -Qe 2>/dev/null | wc -l)
    
    print_status "INFO" "Total packages: $total_packages (${explicit_packages} explicitly installed)"
    
    # Check for updates
    if command_exists checkupdates; then
        if [[ "$HAS_GUM" == true ]]; then
            gum style --foreground "#00aaff" "Checking for updates..."
            updates=$(gum spin --spinner dot --title "Checking package updates..." -- checkupdates 2>/dev/null)
        else
            echo -e "\n\033[0;36mChecking for updates...\033[0m"
            updates=$(checkupdates 2>/dev/null)
        fi
        update_count=$(echo "$updates" | wc -l)
        
        if [[ -n "$updates" && "$updates" != "" ]]; then
            print_status "WARN" "$update_count package update(s) available"
            if [[ "$FULL" == true ]]; then
                if [[ "$HAS_GUM" == true ]]; then
                    # Use gum table for better package update display
                    echo ""
                    gum style --foreground "#ffaa00" --bold "Available Updates:"
                    echo "Package|Current|New" > /tmp/updates_table.txt
                    echo "$updates" | head -10 | awk '{print $1"|"$2"|"$4}' >> /tmp/updates_table.txt
                    gum table < /tmp/updates_table.txt
                    rm -f /tmp/updates_table.txt
                    if [[ $update_count -gt 10 ]]; then
                        gum style --foreground "#666666" --italic "... and $((update_count - 10)) more"
                    fi
                else
                    echo "$updates" | head -10
                    if [[ $update_count -gt 10 ]]; then
                        echo "... and $((update_count - 10)) more"
                    fi
                fi
            fi
        else
            print_status "OK" "System is up to date"
        fi
    else
        print_status "INFO" "checkupdates not available - install pacman-contrib for update checking"
    fi
    
    # AUR updates (if yay is available)
    if command_exists yay; then
        if [[ "$HAS_GUM" == true ]]; then
            aur_updates=$(gum spin --spinner dot --title "Checking AUR updates..." -- sh -c "yay -Qua 2>/dev/null | wc -l")
        else
            echo -e "\n\033[0;36mChecking AUR updates...\033[0m"
            aur_updates=$(yay -Qua 2>/dev/null | wc -l)
        fi
        if [[ $aur_updates -gt 0 ]]; then
            print_status "WARN" "$aur_updates AUR package update(s) available"
        else
            print_status "OK" "AUR packages are up to date"
        fi
    fi
    
    # Orphaned packages
    orphans=$(pacman -Qtdq 2>/dev/null | wc -l)
    if [[ $orphans -gt 0 ]]; then
        print_status "WARN" "$orphans orphaned package(s) found (use: pacman -Qtdq | sudo pacman -Rns -)"
    else
        print_status "OK" "No orphaned packages"
    fi
fi

# Hardware Information
if [[ "$HARDWARE" == true ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸ”§ HARDWARE INFORMATION"
    
    if command_exists inxi; then
        echo -e "${CYAN}System Hardware Overview:${NC}"
        inxi -b 2>/dev/null || print_status "WARN" "inxi command failed"
        
        if [[ "$FULL" == true ]]; then
            echo -e "\n${CYAN}Detailed Hardware Information:${NC}"
            inxi -Fxz 2>/dev/null | head -50
        fi
    else
        print_status "INFO" "inxi not available - showing basic hardware info"
        echo "CPU: $(lscpu | grep 'Model name' | cut -d: -f2 | xargs)"
        echo "Memory: $(free -h | awk '/^Mem:/ {print $2}')"
        echo "Architecture: $(uname -m)"
    fi
    
    # Disk health (basic check)
    echo -e "\n${CYAN}Storage Devices:${NC}"
    lsblk -f 2>/dev/null | grep -E "(NAME|sd|nvme)" || print_status "INFO" "Storage information unavailable"
fi

# Network Status
if [[ "$NETWORK" == true ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸŒ NETWORK STATUS"
    
    # Network interfaces
    if [[ "$HAS_GUM" == true ]]; then
        gum style --foreground "#00aaff" "Network Interfaces:"
    else
        echo -e "\033[0;36mNetwork Interfaces:\033[0m"
    fi
    ip -br addr show 2>/dev/null | grep -v "lo.*127.0.0.1" | while read -r line; do
        interface=$(echo "$line" | awk '{print $1}')
        interface_status=$(echo "$line" | awk '{print $2}')
        ip_addr=$(echo "$line" | awk '{print $3}' | cut -d'/' -f1)
        
        if [[ "$interface_status" == "UP" ]]; then
            print_status "OK" "$interface: $ip_addr"
        else
            print_status "INFO" "$interface: $interface_status"
        fi
    done
    
    # Internet connectivity
    if [[ "$HAS_GUM" == true ]]; then
        gum style --foreground "#00aaff" "Connectivity Test:"
        if gum spin --spinner dot --title "Testing internet connectivity..." -- ping -c 1 -W 2 8.8.8.8 >/dev/null 2>&1; then
            print_status "OK" "Internet connectivity: Available"
        else
            print_status "WARN" "Internet connectivity: Limited or unavailable"
        fi
        
        # DNS resolution test
        if gum spin --spinner dot --title "Testing DNS resolution..." -- nslookup google.com >/dev/null 2>&1; then
            print_status "OK" "DNS resolution: Working"
        else
            print_status "WARN" "DNS resolution: Issues detected"
        fi
    else
        echo -e "\n\033[0;36mConnectivity Test:\033[0m"
        if ping -c 1 -W 2 8.8.8.8 >/dev/null 2>&1; then
            print_status "OK" "Internet connectivity: Available"
        else
            print_status "WARN" "Internet connectivity: Limited or unavailable"
        fi
        
        # DNS resolution test
        if nslookup google.com >/dev/null 2>&1; then
            print_status "OK" "DNS resolution: Working"
        else
            print_status "WARN" "DNS resolution: Issues detected"
        fi
    fi
    
    # Active connections (if requested in full mode)
    if [[ "$FULL" == true ]]; then
        echo -e "\n${CYAN}Active Network Connections:${NC}"
        ss -tuln 2>/dev/null | head -10 || print_status "INFO" "Network connection info unavailable"
    fi
fi

# System Summary
if [[ "$BRIEF" == false && "$SERVICES" == false && "$PACKAGES" == false && "$HARDWARE" == false && "$NETWORK" == false ]] || [[ "$FULL" == true ]]; then
    print_section "ðŸ“‹ SYSTEM SUMMARY"
    
    # Last update check
    if [[ -f /var/log/pacman.log ]]; then
        last_update=$(grep -E "starting full system upgrade|synchronizing package lists" /var/log/pacman.log 2>/dev/null | tail -1 | awk '{print $1, $2}')
        if [[ -n "$last_update" ]]; then
            print_status "INFO" "Last system update: $last_update"
        fi
    fi
    
    # System load status
    load_1min=$(uptime | awk -F'load average:' '{print $2}' | awk -F',' '{print $1}' | xargs)
    cpu_cores=$(nproc)
    
    if (( $(echo "$load_1min > $cpu_cores" | bc -l 2>/dev/null || echo 0) )); then
        print_status "WARN" "System load is high: $load_1min (cores: $cpu_cores)"
    else
        print_status "OK" "System load is normal: $load_1min (cores: $cpu_cores)"
    fi
    
    # Disk space warning
    disk_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    if [[ $disk_usage -gt 90 ]]; then
        print_status "ERROR" "Root filesystem is ${disk_usage}% full"
    elif [[ $disk_usage -gt 80 ]]; then
        print_status "WARN" "Root filesystem is ${disk_usage}% full"
    else
        print_status "OK" "Disk space is adequate (${disk_usage}% used)"
    fi
    
    if [[ "$HAS_GUM" == true ]]; then
        echo ""
        gum style --foreground "#00ff00" --bold "âœ… System health check completed!"
        gum style --foreground "#00aaff" "Run 'system-health --help' for more options, or just 'system-health' for interactive mode."
    else
        echo -e "\n\033[0;32mSystem health check completed.\033[0m"
        echo -e "\033[0;36mUse 'system-health --help' for more options.\033[0m"
    fi
fi