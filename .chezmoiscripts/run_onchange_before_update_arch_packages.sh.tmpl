#!/bin/sh

{{ if eq .chezmoi.os "linux" }}
    {{ if or (eq .chezmoi.osRelease.id "arch") (eq .chezmoi.osRelease.id "endeavouros") }}
    {{- $destinationConfig := index .destinations .destination -}}

# Generate hash for chezmoi run_onchange detection
# Hash: {{ include ".chezmoidata/packages.yaml" | sha256sum }}{{ range $name, $config := .packages.install.arch.packages }}{{ range $config.list }}{{ . }}{{ end }}{{ end }}

echo "Updating packages for destination: {{ .destination }}"
echo "Configured package categories: {{ join ", " $destinationConfig.packages }}"

# Quick check function to determine if updates are needed
check_updates_needed() {
    echo "Checking for package updates and strategy compliance for {{ .destination }} destination..."
    
    # Quick check for system updates
    if ! pacman -Qu >/dev/null 2>&1 && ! yay -Qu >/dev/null 2>&1; then
        echo "No system updates available"
    else
        echo "System updates available"
        return 0
    fi
    
    # Quick strategy compliance check
    local needs_action=false
    {{ range $name, $config := .packages.install.arch.packages -}}
        {{- $strategy := $.packages.install.arch.strategies.default_strategy -}}
        {{- if hasKey $config "strategy" -}}
            {{- $strategy = $config.strategy -}}
        {{- end -}}
        {{- $packages := $config.list -}}
        {{- if $packages }}
            {{- range $packages }}
    if ! is_package_installed "{{ . }}"; then
        echo "Missing package: {{ . }}"
        needs_action=true
    else
        current_source=$(get_package_source "{{ . }}")
        case "$current_source" in
            "pacman")
                {{- if not (has "pacman" $strategy) }}
                echo "Strategy mismatch: {{ . }} (installed via pacman, strategy: {{ join " " $strategy }})"
                needs_action=true
                {{- end }}
                ;;
            "yay_bin")
                {{- if not (has "yay_bin" $strategy) }}
                echo "Strategy mismatch: {{ . }} (installed via yay_bin, strategy: {{ join " " $strategy }})"
                needs_action=true
                {{- end }}
                ;;
            "yay_source")
                {{- if not (has "yay_source" $strategy) }}
                echo "Strategy mismatch: {{ . }} (installed via yay_source, strategy: {{ join " " $strategy }})"
                needs_action=true
                {{- end }}
                ;;
        esac
    fi
            {{- end }}
        {{- end }}
    {{ end -}}
    
    if [ "$needs_action" = "true" ]; then
        echo "Package management actions needed"
        return 0
    else
        echo "All packages are up to date and strategy compliant"
        return 1
    fi
}

# Handle known package transitions that cause file conflicts
handle_package_transitions() {
    echo "Checking for known package transitions..."
    
    # Handle linux-firmware split transition (June 2025)
    if pacman -Qi linux-firmware >/dev/null 2>&1; then
        local current_version=$(pacman -Qi linux-firmware | grep Version | awk '{print $3}' | cut -d'-' -f1)
        local current_date=$(echo "$current_version" | cut -d'.' -f1)
        
        # Check if we have the old monolithic version (before 20250613)
        if [ "$current_date" -lt "20250613" ]; then
            echo "Detected old linux-firmware package that needs transition handling..."
            echo "Current version: $current_version"
            echo "Applying overwrite for NVIDIA firmware files..."
            
            # Use --overwrite to handle the file conflicts during transition
            if sudo pacman -Syu --overwrite="/usr/lib/firmware/nvidia/*" --overwrite="/usr/lib/firmware/amdgpu/*" --overwrite="/usr/lib/firmware/radeon/*" --overwrite="/usr/lib/firmware/intel/*" --noconfirm; then
                echo "✓ Successfully handled linux-firmware package transition"
                return 0
            else
                echo "✗ Failed to handle linux-firmware package transition"
                return 1
            fi
        fi
    fi
    
    # Add future package transitions here as needed
    # Example:
    # if pacman -Qi some-package >/dev/null 2>&1; then
    #     # Handle some-package transition
    # fi
    
    echo "No package transitions detected"
    return 0
}

# Define utility functions
get_package_source() {
    local package="$1"
    
    # Check if package is installed via pacman (official repos)
    if pacman -Qi "$package" >/dev/null 2>&1; then
        # Check if it's from official repos or AUR
        local repo=$(pacman -Qi "$package" | grep "Repository" | awk '{print $3}')
        if [ "$repo" != "aur" ]; then
            echo "pacman"
            return 0
        fi
    fi
    
    # Check if package is installed via yay (AUR)
    if yay -Qi "$package" >/dev/null 2>&1; then
        # Try to determine if it was built from source or binary
        # This is a heuristic - check if package has build files in cache
        if [ -d "/home/$USER/.cache/yay/$package" ] || yay -Qi "$package" | grep -q "Build Date"; then
            echo "yay_source"
        else
            echo "yay_bin"
        fi
        return 0
    fi
    
    # Package not installed
    echo "not_installed"
    return 1
}

# Check if package is available in official repos
is_package_in_official_repos() {
    local package="$1"
    pacman -Si "$package" >/dev/null 2>&1
}

# Determine the best update method for a package based on availability and strategy
get_update_method() {
    local package="$1"
    local strategy="$2"
    local current_source="$3"
    
    # If package is not installed, use strategy for installation
    if [ "$current_source" = "not_installed" ]; then
        echo "$strategy" | awk '{print $1}'
        return 0
    fi
    
    # If package is available in official repos and strategy includes pacman, prefer pacman
    if is_package_in_official_repos "$package"; then
        if echo "$strategy" | grep -q "pacman"; then
            echo "pacman"
            return 0
        fi
    fi
    
    # For AUR packages or when pacman is not in strategy, use yay methods
    if echo "$strategy" | grep -q "yay_bin"; then
        echo "yay_bin"
    elif echo "$strategy" | grep -q "yay_source"; then
        echo "yay_source"
    else
        # Fallback to first method in strategy
        echo "$strategy" | awk '{print $1}'
    fi
}

is_package_installed() {
    local package="$1"
    pacman -Qi "$package" >/dev/null 2>&1 || yay -Qi "$package" >/dev/null 2>&1
}

# Define update functions
update_with_pacman() {
    sudo pacman -Syu --noconfirm --needed "$@"
}

update_with_yay_bin() {
    yay -Syu --noconfirm --needed --norebuild --redownload "$@"
}

update_with_yay_source() {
    yay -Syu --noconfirm --needed --rebuild "$@"
}

# Define installation functions (for missing packages)
install_with_pacman() {
    sudo pacman -S --noconfirm --needed "$@"
}

install_with_yay_bin() {
    yay -S --noconfirm --needed --norebuild --redownload "$@"
}

install_with_yay_source() {
    yay -S --noconfirm --needed --rebuild "$@"
}

# Define reinstallation function
reinstall_package() {
    local package="$1"
    local strategy="$2"
    
    echo "Reinstalling $package with strategy: $strategy"
    
    # Remove the package first
    if is_package_installed "$package"; then
        echo "Removing $package..."
        yay -R --noconfirm "$package" || sudo pacman -R --noconfirm "$package"
    fi
    
    # Install with correct strategy
    for installer in $strategy; do
        if install_with_$installer "$package"; then
            echo "✓ Successfully reinstalled $package with $installer"
            return 0
        fi
    done
    
    echo "✗ Failed to reinstall $package with any method in strategy"
    return 1
}

# Run quick check first
if ! check_updates_needed; then
    echo "No updates needed. Exiting."
    exit 0
fi

echo "Starting comprehensive package update process..."

# Handle package transitions before proceeding with normal updates
if ! handle_package_transitions; then
    echo "Package transition handling failed. Exiting."
    exit 1
fi

# Remove conflicting packages first
echo "Removing conflicting packages..."
yay -R --noconfirm {{ .packages.delete.arch }} 2>/dev/null || true

# Process packages by category (filtered by destination)
{{ range $name, $config := .packages.install.arch.packages -}}
    {{- $strategy := $.packages.install.arch.strategies.default_strategy -}}
    {{- if hasKey $config "strategy" -}}
        {{- $strategy = $config.strategy -}}
    {{- end -}}
    {{- $packages := $config.list -}}
    
    {{- if $packages }}

# Check if {{ $name }} category is enabled for destination {{ $.destination }}
{{ if has $name $destinationConfig.packages }}
echo "Processing {{ $name }} category (enabled for {{ $.destination }} destination)"

# Group packages by their current installation method and required action
packages_to_update_pacman=""
packages_to_update_yay_bin=""
packages_to_update_yay_source=""
packages_to_reinstall=""
packages_to_install=""

        {{- range $packages }}
# Check package: {{ . }}
current_source=$(get_package_source "{{ . }}")
intended_strategy="{{ join " " $strategy }}"
update_method=$(get_update_method "{{ . }}" "$intended_strategy" "$current_source")

case "$current_source" in
    "not_installed")
        packages_to_install="$packages_to_install {{ . }}"
        ;;
    *)
        # Check if current installation method matches the intended strategy
        strategy_match=false
        case "$current_source" in
            "pacman")
                {{- if has "pacman" $strategy }}
                strategy_match=true
                {{- end }}
                ;;
            "yay_bin")
                {{- if has "yay_bin" $strategy }}
                strategy_match=true
                {{- end }}
                ;;
            "yay_source")
                {{- if has "yay_source" $strategy }}
                strategy_match=true
                {{- end }}
                ;;
        esac
        
        # If strategy matches and update method is appropriate, update; otherwise reinstall
        if [ "$strategy_match" = "true" ] && [ "$update_method" = "$current_source" ]; then
            case "$update_method" in
                "pacman")
                    packages_to_update_pacman="$packages_to_update_pacman {{ . }}"
                    ;;
                "yay_bin")
                    packages_to_update_yay_bin="$packages_to_update_yay_bin {{ . }}"
                    ;;
                "yay_source")
                    packages_to_update_yay_source="$packages_to_update_yay_source {{ . }}"
                    ;;
            esac
        else
            packages_to_reinstall="$packages_to_reinstall {{ . }}"
        fi
        ;;
esac
        {{- end }}

# Update packages with correct methods
if [ -n "$packages_to_update_pacman" ]; then
    echo "Updating pacman packages: $packages_to_update_pacman"
    update_with_pacman $packages_to_update_pacman
fi

if [ -n "$packages_to_update_yay_bin" ]; then
    echo "Updating yay binary packages: $packages_to_update_yay_bin"
    update_with_yay_bin $packages_to_update_yay_bin
fi

if [ -n "$packages_to_update_yay_source" ]; then
    echo "Updating yay source packages: $packages_to_update_yay_source"
    update_with_yay_source $packages_to_update_yay_source
fi

# Reinstall packages with wrong installation method
if [ -n "$packages_to_reinstall" ]; then
    echo "Reinstalling packages with correct strategy: $packages_to_reinstall"
    for pkg in $packages_to_reinstall; do
        reinstall_package "$pkg" "{{ join " " $strategy }}"
    done
fi

# Install missing packages
if [ -n "$packages_to_install" ]; then
    echo "Installing missing {{ $name }} packages: $packages_to_install"
        {{- range $index, $installer := $strategy }}
            {{- if eq $index 0 }}
    if install_with_{{ $installer }} $packages_to_install; then
        echo "✓ Successfully installed missing {{ $name }} packages with {{ $installer }}"
            {{- else }}
    elif install_with_{{ $installer }} $packages_to_install; then
        echo "✓ Successfully installed missing {{ $name }} packages with {{ $installer }}"
            {{- end }}
        {{- end }}
    else
        echo "✗ Failed to install missing {{ $name }} packages with any available method"
        exit 1
    fi
fi

echo "✓ Completed processing {{ $name }} packages"
{{ else }}
echo "Skipping {{ $name }} category (not configured for {{ $.destination }} destination)"
{{ end }}

    {{- end }}
{{ end -}}

echo "✓ Package update process completed for {{ .destination }} destination!"
echo "Summary of actions taken:"
echo "- Updated packages using their current correct installation method"
echo "- Reinstalled packages that were installed with incorrect methods"
echo "- Installed any missing packages using defined strategies"

    {{ else }}
        echo "ERROR: This script is only supported on Arch-based systems"
        echo "Required: Arch Linux or EndeavourOS"
        echo "Detected: '{{ .chezmoi.osRelease.id }}'"
        echo "Script: $(basename "$0")"
        exit 1
    {{ end }}
{{ else }}
    echo "ERROR: This script is only supported on Linux systems"
    echo "Required: Linux"
    echo "Detected: '{{ .chezmoi.os }}'"
    echo "Script: $(basename "$0")"
    exit 1
{{ end }}
