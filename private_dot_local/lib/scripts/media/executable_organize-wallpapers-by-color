#!/usr/bin/env bash
# Script: organize-wallpapers-by-color
# Purpose: Organize wallpapers by color similarity to themes using 4-signal scoring
# Location: ~/.local/lib/scripts/media/organize-wallpapers-by-color
# Requirements: Arch Linux, imagemagick (magick), python3

# Source UI library (before set -u to avoid unbound variable errors)
UI_LIB="$HOME/.local/lib/scripts/core/gum-ui.sh"
if [ ! -f "$UI_LIB" ]; then
    echo "Error: UI library not found at $UI_LIB"
    exit 1
fi
# shellcheck source=/dev/null
. "$UI_LIB"

# Default configuration
DEFAULT_SOURCE_DIR="$HOME/.config/wallpapers"
DEFAULT_OUTPUT_DIR="$HOME/.config/wallpapers"
DEFAULT_THRESHOLD=50
THEME_DIR="$HOME/.config/themes"

# Parse command-line arguments
show_help() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

Organize wallpapers by color similarity to themes using automated color matching.

OPTIONS:
    -s, --source DIR      Source wallpaper directory (default: ~/.config/wallpapers)
    -o, --output DIR      Output directory (default: ~/.config/wallpapers)
    -t, --threshold NUM   Match quality threshold 0-100 (default: 50)
                         Higher values = stricter matching
    -h, --help           Show this help message

EXAMPLES:
    # In-place reorganization (reorganize existing wallpapers in ~/.config/wallpapers)
    $(basename "$0")

    # Custom source directory
    $(basename "$0") --source ~/Pictures

    # Explicit in-place reorganization
    $(basename "$0") --source ~/.config/wallpapers --output ~/.config/wallpapers

    # More strict matching
    $(basename "$0") --threshold 60

    # Full customization
    $(basename "$0") -s ~/Pictures -o ~/custom-output -t 55

WORKFLOW:
    1. Extracts dominant colors from each wallpaper using ImageMagick histogram
    2. Classifies colors into background vs accent based on chroma and coverage
    3. Scores wallpapers against themes using 4 signals:
       - Luminance match (35%): dark wallpapers match dark themes
       - Background proximity (35%): wallpaper base tones match theme backgrounds
       - Accent harmony (20%): wallpaper accents complement theme palette
       - Saturation profile (10%): chroma levels suit theme character
    4. Assigns each wallpaper to its best-scoring theme (above threshold)

OUTPUT STRUCTURE:
    {output_dir}/
    ├── catppuccin-latte/
    ├── catppuccin-mocha/
    ├── rose-pine-dawn/
    ├── rose-pine-moon/
    ├── gruvbox-light/
    ├── gruvbox-dark/
    ├── solarized-light/
    ├── solarized-dark/
    └── unassigned/          # Wallpapers below threshold

NEXT STEPS (First-time setup):
    1. Initialize git repository:
       cd {output_dir}
       git init
       git add .
       git commit -m "Initial color-matched wallpaper collection"

    2. Create remote repository (GitHub/GitLab)
       git remote add origin <your-repo-url>
       git push -u origin main

    3. Update .chezmoiexternal.yaml with repository URL
       chezmoi apply --refresh-externals

REORGANIZATION (Existing repositories):
    Script automatically detects git repositories and preserves:
    - Git history and commit log
    - Remote configuration
    - Branch tracking

    After reorganization:
    - Review changes with: cd {output_dir} && git status
    - Commit interactively (script prompts)
    - Or commit manually: git commit -am "Update wallpaper collection"

EOF
}

# Initialize with defaults
SOURCE_DIR="$DEFAULT_SOURCE_DIR"
OUTPUT_DIR="$DEFAULT_OUTPUT_DIR"
MATCH_THRESHOLD="$DEFAULT_THRESHOLD"

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -s|--source)
            SOURCE_DIR="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        -t|--threshold)
            MATCH_THRESHOLD="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            ui_error "Unknown option: $1"
            echo ""
            show_help
            exit 1
            ;;
    esac
done

# Derived configuration
UNASSIGNED_DIR="$OUTPUT_DIR/unassigned"

# Theme list
THEMES=(
    "catppuccin-latte"
    "catppuccin-mocha"
    "rose-pine-dawn"
    "rose-pine-moon"
    "gruvbox-light"
    "gruvbox-dark"
    "solarized-light"
    "solarized-dark"
)

# Git repository detection and status
check_git_status() {
    local dir="$1"

    if [ ! -d "$dir/.git" ]; then
        return 1  # Not a git repo
    fi

    # Check for uncommitted changes
    if ! git -C "$dir" diff-index --quiet HEAD -- 2>/dev/null; then
        return 2  # Uncommitted changes
    fi

    # Check for untracked files
    if [ -n "$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null)" ]; then
        return 3  # Untracked files
    fi

    return 0  # Clean git repo
}

# Validate dependencies
for cmd in magick python3; do
    if ! command -v "$cmd" &> /dev/null; then
        ui_error "Required command not found: $cmd"
        exit 1
    fi
done

# Handle in-place reorganization (source == output)
IN_PLACE_REORGANIZATION=false
if [ "$SOURCE_DIR" = "$OUTPUT_DIR" ]; then
    IN_PLACE_REORGANIZATION=true
    ui_info "In-place reorganization mode"
fi

# Validate source directory
if [ ! -d "$SOURCE_DIR" ]; then
    ui_error "Source directory not found: $SOURCE_DIR"
    ui_info "Either create it, or use --source to specify an existing directory"
    ui_info "For in-place reorganization: --source $OUTPUT_DIR"
    exit 1
fi

# Check if wallpapers exist
WALLPAPER_COUNT=$(find "$SOURCE_DIR" -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.webp" \) 2>/dev/null | wc -l)
if [ "$WALLPAPER_COUNT" -eq 0 ]; then
    ui_error "No wallpapers found in $SOURCE_DIR"
    exit 1
fi

# Temporary directory for intermediate data
TEMP_DIR=$(mktemp -d)
trap 'rm -rf "$TEMP_DIR"' EXIT

# Handle in-place reorganization
if [ "$IN_PLACE_REORGANIZATION" = true ]; then
    ui_step "Preparing in-place reorganization"

    # Copy wallpapers to temporary location
    TEMP_WALLPAPERS="$TEMP_DIR/wallpapers"
    mkdir -p "$TEMP_WALLPAPERS"

    ui_info "Copying wallpapers to temporary location..."
    find "$OUTPUT_DIR" -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.webp" \) \
        -exec cp {} "$TEMP_WALLPAPERS/" \; 2>/dev/null

    # Update SOURCE_DIR to point to temp location
    SOURCE_DIR="$TEMP_WALLPAPERS"

    # Recount wallpapers from temp location
    WALLPAPER_COUNT=$(find "$SOURCE_DIR" -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.webp" \) 2>/dev/null | wc -l)

    ui_success "Copied $WALLPAPER_COUNT wallpapers to temporary location"
fi

# Cleanup existing output directory
if [ -d "$OUTPUT_DIR" ]; then
    ui_warning "Output directory exists: $OUTPUT_DIR"

    # Check if it's a git repository
    if [ -d "$OUTPUT_DIR/.git" ]; then
        ui_info "Detected git repository in output directory"

        # Check git status
        check_git_status "$OUTPUT_DIR"
        git_status=$?

        case $git_status in
            0)
                ui_success "Repository is clean"
                ;;
            2)
                ui_warning "Repository has uncommitted changes"
                ui_info "Changes will be preserved"
                ;;
            3)
                ui_warning "Repository has untracked files"
                ui_info "Untracked files will be preserved"
                ;;
        esac

        if ui_confirm "Reorganize wallpapers while preserving git repository?"; then
            ui_step "Preserving .git directory"

            # Remove only wallpaper files, keep .git and READMEs
            find "$OUTPUT_DIR" -maxdepth 2 -type f \
                \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.webp" \) \
                -delete 2>/dev/null || true

            # Remove empty theme directories (but not .git)
            for theme in "${THEMES[@]}"; do
                [ -d "$OUTPUT_DIR/$theme" ] && rmdir "$OUTPUT_DIR/$theme" 2>/dev/null || true
            done
            [ -d "$UNASSIGNED_DIR" ] && rmdir "$UNASSIGNED_DIR" 2>/dev/null || true

            ui_success "Cleaned wallpaper files (git repository preserved)"
        else
            ui_info "Exiting. No changes made."
            exit 0
        fi
    else
        # Original behavior for non-git directories
        if ui_confirm "Remove and start fresh?"; then
            rm -rf "$OUTPUT_DIR"
        else
            ui_info "Exiting. Remove $OUTPUT_DIR manually if needed."
            exit 0
        fi
    fi
fi

ui_title "Wallpaper Color Analyzer"
ui_info "Source: $SOURCE_DIR ($WALLPAPER_COUNT wallpapers)"
ui_info "Output: $OUTPUT_DIR"
ui_info "Threshold: $MATCH_THRESHOLD/100"
ui_spacer

# Create output structure
ui_step "Creating directory structure"
mkdir -p "$OUTPUT_DIR" "$UNASSIGNED_DIR"
for theme in "${THEMES[@]}"; do
    mkdir -p "$OUTPUT_DIR/$theme"
done
ui_success "Directory structure created"

# Git preservation notification
if [ -d "$OUTPUT_DIR/.git" ]; then
    ui_info "Git repository detected and preserved"
    ui_text "Remote: $(git -C "$OUTPUT_DIR" remote get-url origin 2>/dev/null || echo 'none')" "$FG_MUTED"
fi

ui_spacer

# ============================================================
# Phase 1: Extract theme colors from colors.sh
# ============================================================
ui_step "Extracting theme color palettes"

THEME_COLORS_TSV="$TEMP_DIR/theme_colors.tsv"
: > "$THEME_COLORS_TSV"

for theme in "${THEMES[@]}"; do
    colors_file="$THEME_DIR/$theme/colors.sh"
    if [ ! -f "$colors_file" ]; then
        ui_warning "Theme colors not found: $colors_file"
        continue
    fi

    # Extract background colors (strip # prefix)
    bg_primary=$(grep -oP '(?<=BG_PRIMARY=")[^"]+' "$colors_file" | tr -d '#')
    bg_secondary=$(grep -oP '(?<=BG_SECONDARY=")[^"]+' "$colors_file" | tr -d '#')
    bg_overlay=$(grep -oP '(?<=BG_OVERLAY=")[^"]+' "$colors_file" | tr -d '#')

    # Extract 8 core accent colors
    accent_primary=$(grep -oP '(?<=ACCENT_PRIMARY=")[^"]+' "$colors_file" | tr -d '#')
    accent_info=$(grep -oP '(?<=ACCENT_INFO=")[^"]+' "$colors_file" | tr -d '#')
    accent_success=$(grep -oP '(?<=ACCENT_SUCCESS=")[^"]+' "$colors_file" | tr -d '#')
    accent_warning=$(grep -oP '(?<=ACCENT_WARNING=")[^"]+' "$colors_file" | tr -d '#')
    accent_error=$(grep -oP '(?<=ACCENT_ERROR=")[^"]+' "$colors_file" | tr -d '#')
    accent_highlight=$(grep -oP '(?<=ACCENT_HIGHLIGHT=")[^"]+' "$colors_file" | tr -d '#')
    accent_secondary=$(grep -oP '(?<=ACCENT_SECONDARY=")[^"]+' "$colors_file" | tr -d '#')
    accent_tertiary=$(grep -oP '(?<=ACCENT_TERTIARY=")[^"]+' "$colors_file" | tr -d '#')

    # Format: theme<TAB>bg_colors(space-sep)<TAB>accent_colors(space-sep)
    printf '%s\t%s\t%s\n' \
        "$theme" \
        "$bg_primary $bg_secondary $bg_overlay" \
        "$accent_primary $accent_info $accent_success $accent_warning $accent_error $accent_highlight $accent_secondary $accent_tertiary" \
        >> "$THEME_COLORS_TSV"

    ui_text "$theme: 3 bg + 8 accent colors" "$FG_MUTED"
done
ui_spacer

# ============================================================
# Phase 2: Extract wallpaper colors via ImageMagick histogram
# ============================================================
ui_title "Analyzing Wallpapers"
ui_info "Extracting dominant colors via ImageMagick..."
ui_spacer

WALLPAPER_COLORS_TSV="$TEMP_DIR/wallpaper_colors.tsv"
: > "$WALLPAPER_COLORS_TSV"

# Statistics
PROCESSED=0
SKIPPED=0

# Get list of wallpapers
mapfile -t WALLPAPERS < <(find "$SOURCE_DIR" -type f \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" -o -iname "*.webp" \) 2>/dev/null | sort)

for wallpaper in "${WALLPAPERS[@]}"; do
    filename=$(basename "$wallpaper")
    PROCESSED=$((PROCESSED + 1))

    ui_step "[$PROCESSED/$WALLPAPER_COUNT] $filename"

    # Extract histogram: pixel_count + hex color
    # Resize to 200x200 for speed, quantize to 10 colors
    histogram=$(magick "$wallpaper" -resize 200x200 -colors 10 -depth 8 -format '%c' histogram:info:- 2>/dev/null)

    if [ -z "$histogram" ]; then
        ui_warning "  Failed to analyze, skipping"
        SKIPPED=$((SKIPPED + 1))
        continue
    fi

    # Parse histogram lines: extract pixel_count and hex color
    # Format per line: "  12345: (R,G,B,...) #RRGGBB ..."
    # Output: "count:hex count:hex ..." sorted by count descending
    color_data=$(echo "$histogram" | \
        grep -oP '^\s*(\d+):.*#([0-9A-Fa-f]{6})' | \
        sed -E 's/^\s*([0-9]+):.*#([0-9A-Fa-f]{6}).*/\1:\2/' | \
        sort -t: -k1 -rn)

    if [ -z "$color_data" ]; then
        ui_warning "  No colors extracted, skipping"
        SKIPPED=$((SKIPPED + 1))
        continue
    fi

    # Format: filepath<TAB>count1:hex1 count2:hex2 ...
    color_entries=$(echo "$color_data" | tr '\n' ' ' | sed 's/ $//')
    printf '%s\t%s\n' "$wallpaper" "$color_entries" >> "$WALLPAPER_COLORS_TSV"

    # Show dominant color count
    num_colors=$(echo "$color_data" | wc -l)
    dominant_hex=$(echo "$color_data" | head -1 | cut -d: -f2)
    ui_text "  $num_colors colors, dominant: #$dominant_hex" "$FG_MUTED"
done
ui_spacer

if [ "$SKIPPED" -gt 0 ]; then
    ui_warning "Skipped $SKIPPED wallpapers (extraction failed)"
fi

# ============================================================
# Phase 3: Score all wallpapers x themes via Python batch
# ============================================================
ui_separator
ui_title "Scoring Wallpapers"
ui_info "Computing 4-signal scores..."
ui_spacer

SCORES_TSV="$TEMP_DIR/scores.tsv"

PYTHON_SCORER=$(cat <<'PYTHON_EOF'
import sys
import math

def hex_to_rgb(h):
    """Hex string (no #) -> (R,G,B) 0-255"""
    h = h.strip().lstrip('#')
    if len(h) != 6:
        return None
    try:
        return (int(h[0:2],16), int(h[2:4],16), int(h[4:6],16))
    except ValueError:
        return None

def rgb_to_lab(rgb):
    """(R,G,B) 0-255 -> (L*,a*,b*) CIE-LAB"""
    r, g, b = [c / 255.0 for c in rgb]
    def to_linear(c):
        return c / 12.92 if c <= 0.04045 else ((c + 0.055) / 1.055) ** 2.4
    r, g, b = map(to_linear, (r, g, b))
    x = r * 0.4124564 + g * 0.3575761 + b * 0.1804375
    y = r * 0.2126729 + g * 0.7151522 + b * 0.0721750
    z = r * 0.0193339 + g * 0.1191920 + b * 0.9503041
    def f(t):
        return t ** (1.0/3.0) if t > 0.008856 else 7.787 * t + 16.0/116.0
    xn, yn, zn = 0.95047, 1.00000, 1.08883
    L = 116 * f(y / yn) - 16
    a = 500 * (f(x / xn) - f(y / yn))
    bv = 200 * (f(y / yn) - f(z / zn))
    return (L, a, bv)

def lab_to_lch(lab):
    """(L*,a*,b*) -> (L, C, H) where C=chroma, H=hue in degrees"""
    L, a, b = lab
    C = math.sqrt(a*a + b*b)
    H = math.degrees(math.atan2(b, a)) % 360
    return (L, C, H)

def delta_e(lab1, lab2):
    """CIE76 Delta E"""
    return math.sqrt(sum((a-b)**2 for a,b in zip(lab1, lab2)))

def parse_wallpaper_colors(color_str):
    """Parse 'count1:hex1 count2:hex2 ...' -> [(count, hex, lab, lch), ...]"""
    results = []
    for entry in color_str.strip().split():
        parts = entry.split(':')
        if len(parts) != 2:
            continue
        count = int(parts[0])
        rgb = hex_to_rgb(parts[1])
        if rgb is None:
            continue
        lab = rgb_to_lab(rgb)
        lch = lab_to_lch(lab)
        results.append((count, parts[1], lab, lch))
    return results

def classify_colors(colors):
    """Split wallpaper colors into background and accent lists.
    colors: [(count, hex, lab, lch), ...] sorted by count desc.
    Returns (bg_colors, accent_colors) each as list of (count, hex, lab, lch).
    """
    if not colors:
        return [], []
    bg = [colors[0]]  # dominant is always background
    accent = []
    dominant_lab = colors[0][2]
    for c in colors[1:]:
        count, hexc, lab, lch = c
        chroma = lch[1]
        de = delta_e(lab, dominant_lab)
        # Low chroma or similar to dominant -> background
        if chroma < 15 or de < 15:
            bg.append(c)
        else:
            accent.append(c)
    return bg, accent

def parse_theme_colors(bg_str, accent_str):
    """Parse space-separated hex strings -> list of (hex, lab, lch)"""
    results = []
    for h in bg_str.strip().split() + accent_str.strip().split():
        rgb = hex_to_rgb(h)
        if rgb is None:
            continue
        lab = rgb_to_lab(rgb)
        lch = lab_to_lch(lab)
        results.append((h, lab, lch))
    return results

def parse_hex_list(hex_str):
    """Parse space-separated hex -> [(hex, lab, lch), ...]"""
    results = []
    for h in hex_str.strip().split():
        rgb = hex_to_rgb(h)
        if rgb is None:
            continue
        lab = rgb_to_lab(rgb)
        lch = lab_to_lch(lab)
        results.append((h, lab, lch))
    return results

def score_wallpaper_theme(wp_colors, theme_bg_str, theme_accent_str):
    """Compute composite score (0-100) for wallpaper vs theme.
    wp_colors: [(count, hex, lab, lch), ...]
    Returns (composite_score, s1, s2, s3, s4)
    """
    if not wp_colors:
        return (0, 0, 0, 0, 0)

    theme_bgs = parse_hex_list(theme_bg_str)
    theme_accents = parse_hex_list(theme_accent_str)

    if not theme_bgs:
        return (0, 0, 0, 0, 0)

    bg_primary_lab = theme_bgs[0][1]
    bg_primary_lch = theme_bgs[0][2]
    is_light = bg_primary_lab[0] > 50

    bg_colors, accent_colors = classify_colors(wp_colors)
    total_pixels = sum(c[0] for c in wp_colors)

    # --- Signal 1: Luminance Match (weight 0.35) ---
    dominant_lab = wp_colors[0][2]
    delta_L = abs(dominant_lab[0] - bg_primary_lab[0])
    s1 = max(0, 100 - delta_L * 2.0)

    # --- Signal 2: Background Proximity (weight 0.35) ---
    if bg_colors:
        bg_total_pixels = sum(c[0] for c in bg_colors)
        weighted_sum = 0
        for count, hexc, lab, lch in bg_colors:
            # Find closest theme background
            min_de = min(delta_e(lab, tb[1]) for tb in theme_bgs)
            color_score = max(0, 100 - min_de * 2.0)
            weight = count / bg_total_pixels
            weighted_sum += color_score * weight
        s2 = weighted_sum
    else:
        s2 = 0

    # --- Signal 3: Accent Harmony (weight 0.20) ---
    if accent_colors and theme_accents:
        # Best-3-matches approach
        match_scores = []
        for count, hexc, lab, lch in accent_colors:
            min_de = min(delta_e(lab, ta[1]) for ta in theme_accents)
            match_scores.append(max(0, 100 - min_de * 2.5))
        match_scores.sort(reverse=True)
        best_3 = match_scores[:3]
        s3 = sum(best_3) / len(best_3)
    elif not accent_colors:
        # Monochrome wallpaper - neutral score
        s3 = 50
    else:
        s3 = 0

    # --- Signal 4: Saturation Profile (weight 0.10) ---
    # Average chroma weighted by coverage
    if total_pixels > 0:
        avg_chroma = sum(c[0] * c[3][1] for c in wp_colors) / total_pixels
    else:
        avg_chroma = 0

    if is_light:
        # Light themes: peak at moderate chroma (~30)
        s4 = max(0, 100 - abs(avg_chroma - 30) * 2.5)
    else:
        # Dark themes: wider peak, centered higher (~40)
        s4 = max(0, 100 - abs(avg_chroma - 40) * 2.0)

    # --- Composite ---
    composite = 0.35 * s1 + 0.35 * s2 + 0.20 * s3 + 0.10 * s4

    return (composite, s1, s2, s3, s4)


def main():
    if len(sys.argv) != 4:
        print("Usage: score.py <wallpaper_tsv> <theme_tsv> <output_tsv>", file=sys.stderr)
        sys.exit(1)

    wp_tsv = sys.argv[1]
    theme_tsv = sys.argv[2]
    out_tsv = sys.argv[3]

    # Load themes: {name: (bg_str, accent_str)}
    themes = {}
    with open(theme_tsv) as f:
        for line in f:
            parts = line.strip().split('\t')
            if len(parts) >= 3:
                themes[parts[0]] = (parts[1], parts[2])

    # Load wallpapers and score
    results = []
    with open(wp_tsv) as f:
        for line in f:
            parts = line.strip().split('\t')
            if len(parts) < 2:
                continue
            wp_path = parts[0]
            wp_colors = parse_wallpaper_colors(parts[1])

            best_theme = ""
            best_score = -1
            all_scores = {}

            for theme_name, (bg_str, accent_str) in themes.items():
                composite, s1, s2, s3, s4 = score_wallpaper_theme(wp_colors, bg_str, accent_str)
                all_scores[theme_name] = (composite, s1, s2, s3, s4)
                if composite > best_score:
                    best_score = composite
                    best_theme = theme_name

            # Output: wp_path<TAB>best_theme<TAB>best_score<TAB>s1<TAB>s2<TAB>s3<TAB>s4
            if best_theme and best_theme in all_scores:
                sc = all_scores[best_theme]
                results.append((wp_path, best_theme, sc[0], sc[1], sc[2], sc[3], sc[4]))

    with open(out_tsv, 'w') as f:
        for r in results:
            f.write(f"{r[0]}\t{r[1]}\t{r[2]:.1f}\t{r[3]:.1f}\t{r[4]:.1f}\t{r[5]:.1f}\t{r[6]:.1f}\n")


if __name__ == "__main__":
    main()
PYTHON_EOF
)

# Write Python script to temp and run batch scoring
PYTHON_FILE="$TEMP_DIR/scorer.py"
echo "$PYTHON_SCORER" > "$PYTHON_FILE"

python3 "$PYTHON_FILE" "$WALLPAPER_COLORS_TSV" "$THEME_COLORS_TSV" "$SCORES_TSV"

if [ ! -f "$SCORES_TSV" ] || [ ! -s "$SCORES_TSV" ]; then
    ui_error "Scoring failed - no results produced"
    exit 1
fi

ui_success "Scoring complete"
ui_spacer

# ============================================================
# Phase 4: Assign wallpapers based on best score
# ============================================================
ui_separator
ui_title "Assigning Wallpapers"
ui_spacer

declare -A THEME_COUNTS
for theme in "${THEMES[@]}"; do
    THEME_COUNTS[$theme]=0
done
UNASSIGNED_COUNT=0
ASSIGNED_COUNT=0

while IFS=$'\t' read -r wp_path best_theme score _s1 _s2 _s3 _s4; do
    filename=$(basename "$wp_path")

    # Score is 0-100, threshold check
    if awk -v s="$score" -v t="$MATCH_THRESHOLD" 'BEGIN { exit !(s >= t) }'; then
        cp "$wp_path" "$OUTPUT_DIR/$best_theme/"
        THEME_COUNTS[$best_theme]=$((THEME_COUNTS[$best_theme] + 1))
        ASSIGNED_COUNT=$((ASSIGNED_COUNT + 1))
        ui_text "  $filename -> $best_theme (${score})" "$FG_MUTED"
    else
        cp "$wp_path" "$UNASSIGNED_DIR/"
        UNASSIGNED_COUNT=$((UNASSIGNED_COUNT + 1))
        ui_text "  $filename -> unassigned (${score} < $MATCH_THRESHOLD)" "$FG_MUTED"
    fi
done < "$SCORES_TSV"

ui_spacer
ui_success "Assigned $ASSIGNED_COUNT wallpapers to themes"
if [ "$UNASSIGNED_COUNT" -gt 0 ]; then
    ui_warning "$UNASSIGNED_COUNT wallpapers below threshold"
fi

# Create READMEs
for theme in "${THEMES[@]}"; do
    cat > "$OUTPUT_DIR/$theme/README.md" <<EOF
# $theme Wallpapers

Color-matched wallpapers for the $theme theme.

**Assignment Method**: 4-signal color scoring (ImageMagick + CIE-LAB)
**Match Count**: ${THEME_COUNTS[$theme]} wallpapers
**Match Threshold**: $MATCH_THRESHOLD (0-100 scale)

These wallpapers were automatically selected based on luminance, background proximity,
accent harmony, and saturation profile matching against the theme's color palette.
EOF
done

cat > "$UNASSIGNED_DIR/README.md" <<EOF
# Unassigned Wallpapers

Wallpapers that did not match any theme above the threshold.

**Count**: $UNASSIGNED_COUNT wallpapers
**Threshold**: $MATCH_THRESHOLD (0-100 scale)

These wallpapers can be:
1. Manually assigned to themes if desired
2. Excluded from the collection
3. Used to adjust threshold and re-run

To adjust threshold: Re-run script with --threshold option
EOF

# Main README
cat > "$OUTPUT_DIR/README.md" <<EOF
# Wallpaper Collection

Personal wallpaper collection organized by theme using automated color matching.

## Organization Method

Wallpapers were automatically assigned using a **4-signal scoring model**:

1. **Luminance Match** (35%): Ensures dark wallpapers match dark themes, light match light
2. **Background Proximity** (35%): Wallpaper base tones match theme background colors
3. **Accent Harmony** (20%): Wallpaper accent colors complement the theme palette
4. **Saturation Profile** (10%): Chroma levels suit the theme's character

Color data extracted via ImageMagick histogram analysis with pixel coverage weighting.
Scoring uses CIE-LAB perceptual color space with Delta E distance.

## Statistics

**Total Wallpapers**: $WALLPAPER_COUNT
**Match Threshold**: $MATCH_THRESHOLD (0-100 scale)
**Source Directory**: $SOURCE_DIR

### Theme Distribution

$(for theme in "${THEMES[@]}"; do
    count=${THEME_COUNTS[$theme]}
    echo "- **$theme**: $count wallpapers"
done)

### Unassigned

- **unassigned**: $UNASSIGNED_COUNT wallpapers (below threshold)

## Repository Structure

\`\`\`
wallpapers/
├── catppuccin-latte/
├── catppuccin-mocha/
├── gruvbox-dark/
├── gruvbox-light/
├── rose-pine-dawn/
├── rose-pine-moon/
├── solarized-dark/
├── solarized-light/
└── unassigned/
\`\`\`

## Usage

This repository is pulled automatically by chezmoi via \`.chezmoiexternal.yaml\`.

Wallpapers are accessed from \`~/.config/wallpapers/{theme}/\`.

## Maintenance

To re-analyze wallpapers:

\`\`\`bash
# Re-run with same settings
~/.local/lib/scripts/media/organize-wallpapers-by-color

# Adjust threshold for more/less inclusive matching
~/.local/lib/scripts/media/organize-wallpapers-by-color --threshold 60

# Custom source directory
~/.local/lib/scripts/media/organize-wallpapers-by-color --source ~/Pictures/Wallpapers
\`\`\`

After re-running:
1. Review unassigned directory
2. Commit and push changes to this repository
EOF

# Git integration (if repository exists)
if [ -d "$OUTPUT_DIR/.git" ]; then
    ui_separator
    ui_title "Git Integration"
    ui_spacer

    # Show git status before staging
    ui_step "Checking repository status"
    git -C "$OUTPUT_DIR" status --short
    ui_spacer

    if ui_confirm "Stage reorganized wallpapers?"; then
        ui_step "Staging changes"
        git -C "$OUTPUT_DIR" add .
        ui_success "Changes staged"
        ui_spacer

        # Generate commit message
        commit_msg="Reorganize wallpapers by color matching

Statistics:
- Total wallpapers: $WALLPAPER_COUNT
- Match threshold: $MATCH_THRESHOLD
- Theme distribution:
$(for theme in "${THEMES[@]}"; do
    count=${THEME_COUNTS[$theme]}
    [ "$count" -gt 0 ] && echo "  - $theme: $count"
done)
- Unassigned: $UNASSIGNED_COUNT

Generated by organize-wallpapers-by-color"

        if ui_confirm "Create commit with auto-generated message?"; then
            git -C "$OUTPUT_DIR" commit -m "$commit_msg"
            ui_success "Commit created"
            ui_spacer

            # Show commit details
            git -C "$OUTPUT_DIR" show --stat --oneline HEAD
            ui_spacer

            if ui_confirm "Push to remote?"; then
                ui_step "Pushing to remote..."

                # Use timeout to prevent hanging on authentication
                if timeout 30 git -C "$OUTPUT_DIR" push 2>&1; then
                    ui_success "Changes pushed to remote"
                else
                    exit_code=$?
                    if [ $exit_code -eq 124 ]; then
                        ui_warning "Push timed out (likely waiting for authentication)"
                        ui_info "This usually means SSH key needs passphrase or credentials are required"
                    else
                        ui_warning "Push failed (exit code: $exit_code)"
                    fi
                    ui_info "Push manually with: cd $OUTPUT_DIR && git push"
                fi
            else
                ui_info "Commit created but not pushed"
                ui_info "Push manually with: cd $OUTPUT_DIR && git push"
            fi
        else
            ui_info "Changes staged but not committed"
            ui_info "Commit manually with: cd $OUTPUT_DIR && git commit"
        fi
    else
        ui_info "No changes staged"
    fi
fi

# Summary
ui_separator
ui_title "Color Matching Complete!"
ui_spacer

ui_success "Processed: $PROCESSED wallpapers"
ui_spacer

ui_info "Theme Distribution:"
for theme in "${THEMES[@]}"; do
    count=${THEME_COUNTS[$theme]}
    if [ "$count" -gt 0 ]; then
        ui_success "  $theme: $count wallpapers"
    else
        ui_text "  $theme: 0 wallpapers" "$FG_MUTED"
    fi
done
ui_spacer

if [ "$UNASSIGNED_COUNT" -gt 0 ]; then
    ui_warning "Unassigned: $UNASSIGNED_COUNT wallpapers"
    ui_info "Review in: $UNASSIGNED_DIR"
    ui_text "Re-run with lower --threshold if needed" "$FG_MUTED"
fi
ui_spacer

ui_title "Next Steps"
ui_step "1. Review assignment results"
ui_output "   cd $OUTPUT_DIR"
ui_output "   # Check each theme directory"
ui_spacer

ui_step "2. Initialize git repository"
ui_output "   cd $OUTPUT_DIR"
ui_output "   git init"
ui_output "   git add ."
ui_output "   git commit -m 'Initial color-matched wallpaper collection'"
ui_spacer

ui_step "3. Create remote repository"
ui_info "Create a private repository on GitHub/GitLab"
ui_output "   GitHub: https://github.com/new"
ui_output "   GitLab: https://gitlab.com/projects/new"
ui_spacer

ui_step "4. Push to remote"
ui_output "   git remote add origin <your-repo-url>"
ui_output "   git branch -M main"
ui_output "   git push -u origin main"
ui_spacer

ui_step "5. Update chezmoi configuration"
ui_info "The repository URL is already in .chezmoiexternal.yaml"
ui_info "Then run: chezmoi apply --refresh-externals"
ui_spacer

ui_success "Wallpaper organization complete!"
ui_info "Output: $OUTPUT_DIR"
