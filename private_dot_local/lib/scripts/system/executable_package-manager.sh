#!/usr/bin/env bash

# Package Manager - Module-based declarative package management with version pinning
# Purpose: NixOS/dcli-inspired package management for Arch Linux
# Requirements: Arch Linux, paru, yq, gum (UI library)
# Version: 2.1.0 (dcli v2 improvements: merge, snapper, performance)

# Source the UI library
if [ -f "$UI_LIB" ]; then
    . "$UI_LIB"
else
    echo "Error: UI library not found at $UI_LIB" >&2
    exit 1
fi

# =============================================================================
# GLOBAL CONFIGURATION
# =============================================================================

PACKAGES_FILE="$HOME/.local/share/chezmoi/.chezmoidata/packages.yaml"
STATE_DIR="$HOME/.local/state/package-manager"
STATE_FILE="$STATE_DIR/package-state.yaml"
LOCKFILE="$STATE_DIR/locked-versions.yaml"

# Ensure state directory exists
mkdir -p "$STATE_DIR"

# =============================================================================
# STATE FILE I/O
# =============================================================================

_init_state_file() {
    if [[ ! -f "$STATE_FILE" ]]; then
        cat > "$STATE_FILE" << 'EOF'
# Package state file
# Generated by package-manager
# Tracks installed packages with metadata

packages: []
EOF
    fi
}

_read_state() {
    _init_state_file
    yq eval '.packages' "$STATE_FILE"
}

_update_package_state() {
    local name="$1"
    local version="$2"
    local type="${3:-pacman}"  # pacman or flatpak
    local module="${4:-unknown}"
    local constraint="${5:-null}"

    _init_state_file

    local timestamp=$(date -Iseconds)

    # Remove existing entry
    yq eval "del(.packages[] | select(.name == \"$name\"))" -i "$STATE_FILE"

    # Add new entry
    local pinned="false"
    [[ "$constraint" != "null" ]] && pinned="true"

    local package_entry=$(cat <<EOF
{
  "name": "$name",
  "version": "$version",
  "type": "$type",
  "module": "$module",
  "constraint": $constraint,
  "pinned": $pinned,
  "installed_at": "$timestamp",
  "last_updated": "$timestamp"
}
EOF
)
    yq eval ".packages += [$package_entry]" -i "$STATE_FILE"
}

# =============================================================================
# PACKAGE TYPE DETECTION
# =============================================================================

_is_flatpak() {
    local package="$1"
    [[ "$package" == flatpak:* ]]
}

_strip_flatpak_prefix() {
    local package="$1"
    echo "${package#flatpak:}"
}

_is_rolling_package() {
    local package="$1"
    [[ "$package" == *"-git" ]]
}

_parse_package_constraint() {
    # Parses package constraint and returns: name|version|constraint_type
    # Formats:
    #   - "linux" -> "linux||none"
    #   - {name: linux, version: "6.6.1"} -> "linux|6.6.1|exact"
    #   - {name: linux, version: ">=6.6"} -> "linux|6.6|minimum"
    #   - {name: linux, version: "<6.7"} -> "linux|6.7|maximum"

    local package="$1"

    # Simple string (no constraint)
    if [[ ! "$package" =~ ^name: ]]; then
        echo "$package||none"
        return
    fi

    # Parse YAML object (requires yq)
    local name=$(echo "$package" | yq eval '.name' -)
    local version=$(echo "$package" | yq eval '.version // ""' -)

    if [[ -z "$version" || "$version" == "null" ]]; then
        echo "$name||none"
    elif [[ "$version" =~ ^">=" ]]; then
        echo "$name|${version#>=}|minimum"
    elif [[ "$version" =~ ^"<" ]]; then
        echo "$name|${version#<}|maximum"
    else
        echo "$name|$version|exact"
    fi
}

# =============================================================================
# VERSION UTILITIES
# =============================================================================

_compare_versions() {
    # Use pacman's vercmp for accurate version comparison
    # Returns: 0 if v1 == v2, 1 if v1 > v2, -1 if v1 < v2 (inverted from vercmp)
    local v1="$1"
    local v2="$2"

    if [[ -z "$v1" || -z "$v2" ]]; then
        return 0
    fi

    # vercmp returns: -1 if v1 < v2, 0 if v1 == v2, 1 if v1 > v2
    local result=$(vercmp "$v1" "$v2")

    # Return vercmp result directly
    case "$result" in
        -1) return 2 ;;  # v1 < v2
        0) return 0 ;;   # v1 == v2
        1) return 1 ;;   # v1 > v2
    esac
}

_get_package_version() {
    local pkg="$1"
    pacman -Q "$pkg" 2>/dev/null | awk '{print $2}' || true
}

_get_repo_version() {
    local pkg="$1"
    pacman -Si "$pkg" 2>/dev/null | grep "^Version" | awk '{print $3}' || true
}

_get_flatpak_version() {
    local app_id="$1"
    flatpak list --app --columns=application,version --user 2>/dev/null | grep "^${app_id}" | awk '{print $2}' || true
}

# =============================================================================
# PACKAGE VALIDATION
# =============================================================================

_check_package_exists() {
    # Check if a package exists in official repos or AUR
    # Returns: 0 if exists, 1 if not found
    local pkg="$1"

    # Check official repos first (fastest)
    if pacman -Si "$pkg" &>/dev/null; then
        return 0
    fi

    # Check AUR with paru (15-second timeout to prevent hangs)
    if command -v paru >/dev/null 2>&1; then
        if timeout 15 paru -Si "$pkg" &>/dev/null 2>&1; then
            return 0
        fi

    fi

    return 1
}

_check_packages_batch() {
    # Batch check if packages exist (more efficient for validation)
    # Prints invalid package names to stdout
    local packages=("$@")

    # First, check all packages against official repos (fast)
    local -A repo_packages
    for pkg in "${packages[@]}"; do
        if pacman -Si "$pkg" &>/dev/null 2>&1; then
            repo_packages[$pkg]=1
        fi
    done

    # For packages not in repos, check AUR
    local remaining_packages=()
    for pkg in "${packages[@]}"; do
        if [[ -z "${repo_packages[$pkg]:-}" ]]; then
            remaining_packages+=("$pkg")
        fi
    done

        # Check remaining packages in AUR with timeout
    if [[ ${#remaining_packages[@]} -gt 0 ]]; then
        local aur_helper=""
        if command -v paru >/dev/null 2>&1; then
            aur_helper="paru"
        fi

        if [[ -n "$aur_helper" ]]; then
            for pkg in "${remaining_packages[@]}"; do
                if ! timeout 15 $aur_helper -Si "$pkg" &>/dev/null 2>&1; then
                    echo "$pkg"
                fi
            done
        else
            # No AUR helper, assume all remaining are invalid
            printf '%s\n' "${remaining_packages[@]}"
        fi
    fi
}

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

_log_verbose() {
    local message="$1"
    [[ "$VERBOSE" == "true" ]] && ui_info "$message"
    return 0
}

_execute_or_dry_run() {
    local description="$1"
    local command="$2"

    if [[ "$DRY_RUN" == "true" ]]; then
        ui_info "[DRY-RUN] Would run: $command"
        return 0
    fi

    _log_verbose "$description"
    eval "$command" 2>/dev/null
}

_check_yq_dependency() {
    if ! command -v yq >/dev/null 2>&1; then
        ui_error "yq is required. Install with: paru -S go-yq"
        return 1
    fi
    return 0
}

_get_aur_helper() {
    # Detect AUR helper (paru only)
    if command -v paru &>/dev/null; then
        echo "paru"
    else
        echo ""
    fi
}

# =============================================================================
# SECTION 2: MODULE SYSTEM
# =============================================================================

_get_modules() {
    _check_yq_dependency || return 1
    yq eval '.packages.modules | keys | .[]' "$PACKAGES_FILE" 2>/dev/null
}

_get_enabled_modules() {
    _check_yq_dependency || return 1
    yq eval '.packages.modules | to_entries | .[] | select(.value.enabled == true) | .key' "$PACKAGES_FILE" 2>/dev/null
}

_get_module_packages() {
    local module="$1"
    _check_yq_dependency || return 1
    yq eval ".packages.modules.${module}.packages | .[]" "$PACKAGES_FILE" 2>/dev/null
}

_is_module_enabled() {
    local module="$1"
    _check_yq_dependency || return 1
    local enabled=$(yq eval ".packages.modules.${module}.enabled" "$PACKAGES_FILE" 2>/dev/null)
    [[ "$enabled" == "true" ]]
}

_get_module_conflicts() {
    local module="$1"
    _check_yq_dependency || return 1
    yq eval ".packages.modules.${module}.conflicts[]?" "$PACKAGES_FILE" 2>/dev/null
}

cmd_module_list() {
    _check_yq_dependency || return 1

    ui_title "ðŸ“¦ Package Modules"
    echo ""

    while IFS= read -r module; do
        [[ -z "$module" ]] && continue

        local enabled=$(yq eval ".packages.modules.${module}.enabled" "$PACKAGES_FILE" 2>/dev/null)
        local description=$(yq eval ".packages.modules.${module}.description" "$PACKAGES_FILE" 2>/dev/null)
        local pkg_count=$(yq eval ".packages.modules.${module}.packages | length" "$PACKAGES_FILE" 2>/dev/null)

        if [[ "$enabled" == "true" ]]; then
            ui_success "  âœ“ ${module} (${pkg_count} packages) - ${description}"
        else
            ui_info "  âœ— ${module} (${pkg_count} packages) - ${description}" | ui_color gray
        fi
    done < <(_get_modules)
}

cmd_module_enable_interactive() {
    _check_yq_dependency || return 1

    ui_title "ðŸ“¦ Enable Modules"
    echo ""

    # Collect disabled modules
    local -a disabled_modules=()
    local -a module_names=()
    local -a module_descriptions=()

    while IFS= read -r module; do
        [[ -z "$module" ]] && continue

        if ! _is_module_enabled "$module"; then
            module_names+=("$module")

            local description=$(yq eval ".packages.modules.${module}.description" "$PACKAGES_FILE" 2>/dev/null)
            [[ -z "$description" || "$description" == "null" ]] && description="No description"
            module_descriptions+=("$description")
        fi
    done < <(_get_modules)

    if [[ ${#module_names[@]} -eq 0 ]]; then
        ui_warning "All modules are already enabled"
        return 0
    fi

    ui_info "Select modules to enable (comma or space separated):"
    echo ""

    local i=1
    for idx in "${!module_names[@]}"; do
        ui_info "  ${i}) ${module_names[$idx]}"
        ui_info "     ${module_descriptions[$idx]}"
        ui_spacer
        ((i++))
    done

    read -p "Selection (or 'q' to quit): " selection

    if [[ "$selection" == "q" ]] || [[ -z "$selection" ]]; then
        ui_warning "Cancelled"
        return 0
    fi

    # Parse selection (handle comma and space separated)
    selection="${selection//,/ }"
    local -a selected_numbers=($selection)

    local enabled_count=0
    for num in "${selected_numbers[@]}"; do
        # Validate number
        if ! [[ "$num" =~ ^[0-9]+$ ]]; then
            ui_error "Invalid selection: $num"
            continue
        fi

        local idx=$((num - 1))
        if [[ $idx -lt 0 ]] || [[ $idx -ge ${#module_names[@]} ]]; then
            ui_error "Invalid selection: $num"
            continue
        fi

        local module_to_enable="${module_names[$idx]}"
        echo ""
        cmd_module_enable "$module_to_enable"
        ((enabled_count++))
    done

    if [[ $enabled_count -gt 0 ]]; then
        echo ""
        ui_success "Enabled $enabled_count module(s)"
        ui_info "Run 'package-manager sync' to install packages"
    fi
}

cmd_module_enable() {
    local module="$1"
    _check_yq_dependency || return 1

    if [[ -z "$module" ]]; then
        ui_error "Module name required"
        return 1
    fi

    # Check if module exists
    if ! yq eval ".packages.modules | has(\"$module\")" "$PACKAGES_FILE" 2>/dev/null | grep -q "true"; then
        ui_error "Module '$module' not found"
        return 1
    fi

    # Check if already enabled
    if _is_module_enabled "$module"; then
        ui_warning "Module '$module' is already enabled"
        return 0
    fi

    # Check for conflicts
    local conflicts=$(_get_module_conflicts "$module")
    if [[ -n "$conflicts" ]]; then
        while IFS= read -r conflict; do
            [[ -z "$conflict" ]] && continue

            if _is_module_enabled "$conflict"; then
                ui_warning "Module '$module' conflicts with enabled module '$conflict'"

                if ui_confirm "Disable '$conflict' and enable '$module'?"; then
                    # Disable conflicting module
                    yq eval ".packages.modules.${conflict}.enabled = false" -i "$PACKAGES_FILE"
                    ui_success "Disabled '$conflict'"
                else
                    ui_warning "Cancelled"
                    return 0
                fi
            fi
        done <<< "$conflicts"
    fi

    # Enable module
    yq eval ".packages.modules.${module}.enabled = true" -i "$PACKAGES_FILE"
    ui_success "Module '$module' enabled"
    ui_info "Run 'package-manager sync' to install packages"
}

cmd_module_disable_interactive() {
    _check_yq_dependency || return 1

    ui_title "ðŸ“¦ Disable Modules"
    echo ""

    # Collect enabled modules
    local -a module_names=()
    local -a module_descriptions=()

    while IFS= read -r module; do
        [[ -z "$module" ]] && continue

        module_names+=("$module")

        local description=$(yq eval ".packages.modules.${module}.description" "$PACKAGES_FILE" 2>/dev/null)
        [[ -z "$description" || "$description" == "null" ]] && description="No description"
        module_descriptions+=("$description")
    done < <(_get_enabled_modules)

    if [[ ${#module_names[@]} -eq 0 ]]; then
        ui_warning "No modules are currently enabled"
        return 0
    fi

    ui_info "Select modules to disable (comma or space separated):"
    echo ""

    local i=1
    for idx in "${!module_names[@]}"; do
        ui_info "  ${i}) ${module_names[$idx]}"
        ui_info "     ${module_descriptions[$idx]}"
        ui_spacer
        ((i++))
    done

    read -p "Selection (or 'q' to quit): " selection

    if [[ "$selection" == "q" ]] || [[ -z "$selection" ]]; then
        ui_warning "Cancelled"
        return 0
    fi

    # Parse selection (handle comma and space separated)
    selection="${selection//,/ }"
    local -a selected_numbers=($selection)

    local disabled_count=0
    for num in "${selected_numbers[@]}"; do
        # Validate number
        if ! [[ "$num" =~ ^[0-9]+$ ]]; then
            ui_error "Invalid selection: $num"
            continue
        fi

        local idx=$((num - 1))
        if [[ $idx -lt 0 ]] || [[ $idx -ge ${#module_names[@]} ]]; then
            ui_error "Invalid selection: $num"
            continue
        fi

        local module_to_disable="${module_names[$idx]}"
        echo ""
        cmd_module_disable "$module_to_disable"
        ((disabled_count++))
    done

    if [[ $disabled_count -gt 0 ]]; then
        echo ""
        ui_success "Disabled $disabled_count module(s)"
        ui_info "Run 'package-manager sync --prune' to remove packages"
    fi
}

cmd_module_disable() {
    local module="$1"
    _check_yq_dependency || return 1

    if [[ -z "$module" ]]; then
        ui_error "Module name required"
        return 1
    fi

    # Check if module exists
    if ! yq eval ".packages.modules | has(\"$module\")" "$PACKAGES_FILE" 2>/dev/null | grep -q "true"; then
        ui_error "Module '$module' not found"
        return 1
    fi

    # Check if enabled
    if ! _is_module_enabled "$module"; then
        ui_warning "Module '$module' is not enabled"
        return 0
    fi

    # Disable module
    yq eval ".packages.modules.${module}.enabled = false" -i "$PACKAGES_FILE"
    ui_success "Module '$module' disabled"
    ui_info "Run 'package-manager sync --prune' to remove packages"
}

# =============================================================================
# SECTION 3: VERSION PINNING
# =============================================================================

cmd_pin() {
    local package="$1"
    local version="$2"
    _check_yq_dependency || return 1

    if [[ -z "$package" ]]; then
        ui_error "Package name required"
        ui_info "Usage: package-manager pin <package> [version]"
        return 1
    fi

    # Check if it's a flatpak (strip prefix for checks)
    local is_flatpak=false
    local pkg_name="$package"
    if _is_flatpak "$package"; then
        is_flatpak=true
        pkg_name=$(_strip_flatpak_prefix "$package")
    fi

    # If no version specified, use currently installed version
    if [[ -z "$version" ]]; then
        if [[ "$is_flatpak" == "true" ]]; then
            version=$(_get_flatpak_version "$pkg_name")
            if [[ -z "$version" ]]; then
                ui_error "Flatpak '$pkg_name' not installed and no version specified"
                return 1
            fi
            ui_info "Pinning flatpak '$pkg_name' to current version: $version"
        else
            version=$(_get_package_version "$pkg_name")
            if [[ -z "$version" ]]; then
                ui_error "Package '$pkg_name' not installed and no version specified"
                return 1
            fi
            ui_info "Pinning '$pkg_name' to current version: $version"
        fi
    fi

    # Warn about rolling packages
    if _is_rolling_package "$pkg_name"; then
        ui_warning "âš ï¸  '$pkg_name' is a -git package (rolling release)"
        ui_warning "Version pinning not recommended for rolling packages"
        ui_warning "The version will change with every build"
        echo ""

        if ! ui_confirm "Continue with pinning anyway?"; then
            ui_info "Cancelled"
            return 0
        fi
    fi

    # Find package in modules and update to object format
    local found=false
    local found_module=""

    while IFS= read -r module; do
        [[ -z "$module" ]] && continue

        # Check if package exists in this module (as simple string)
        local has_simple=$(yq eval ".packages.modules.${module}.packages[] | select(. == \"$package\")" "$PACKAGES_FILE" 2>/dev/null)

        if [[ -n "$has_simple" ]]; then
            # Found as simple string, convert to object with version
            local pkg_index=$(yq eval ".packages.modules.${module}.packages | to_entries | .[] | select(.value == \"$package\") | .key" "$PACKAGES_FILE" | head -1)

            yq eval ".packages.modules.${module}.packages[${pkg_index}] = {\"name\": \"$package\", \"version\": \"$version\"}" -i "$PACKAGES_FILE"
            found=true
            found_module="$module"
            break
        fi

        # Check if already exists as object
        local has_object=$(yq eval ".packages.modules.${module}.packages[] | select(.name == \"$package\")" "$PACKAGES_FILE" 2>/dev/null)

        if [[ -n "$has_object" ]]; then
            # Update existing object
            local pkg_index=$(yq eval ".packages.modules.${module}.packages | to_entries | .[] | select(.value.name == \"$package\") | .key" "$PACKAGES_FILE" | head -1)

            yq eval ".packages.modules.${module}.packages[${pkg_index}].version = \"$version\"" -i "$PACKAGES_FILE"
            found=true
            found_module="$module"
            break
        fi
    done < <(_get_enabled_modules)

    if [[ "$found" == "false" ]]; then
        ui_error "Package '$package' not found in any enabled module"
        ui_info "Enable the module containing this package first"
        return 1
    fi

    ui_success "Pinned '$package' to version $version in module '$found_module'"
    ui_info "Run 'package-manager sync' to apply version constraint"
}

cmd_unpin() {
    local package="$1"
    _check_yq_dependency || return 1

    if [[ -z "$package" ]]; then
        ui_error "Package name required"
        ui_info "Usage: package-manager unpin <package>"
        return 1
    fi

    # Find and simplify package entry (object -> string)
    local found=false
    local found_module=""

    while IFS= read -r module; do
        [[ -z "$module" ]] && continue

        # Check if exists as object with version
        local has_object=$(yq eval ".packages.modules.${module}.packages[] | select(.name == \"$package\")" "$PACKAGES_FILE" 2>/dev/null)

        if [[ -n "$has_object" ]]; then
            # Check if it has a version field
            local pkg_index=$(yq eval ".packages.modules.${module}.packages | to_entries | .[] | select(.value.name == \"$package\") | .key" "$PACKAGES_FILE" | head -1)
            local has_version=$(yq eval ".packages.modules.${module}.packages[${pkg_index}] | has(\"version\")" "$PACKAGES_FILE" 2>/dev/null)

            if [[ "$has_version" == "true" ]]; then
                # Replace object with simple string
                yq eval ".packages.modules.${module}.packages[${pkg_index}] = \"$package\"" -i "$PACKAGES_FILE"
                found=true
                found_module="$module"
                break
            fi
        fi
    done < <(_get_enabled_modules)

    if [[ "$found" == "false" ]]; then
        ui_warning "Package '$package' is not pinned"
        return 0
    fi

    ui_success "Unpinned '$package' in module '$found_module'"
    ui_info "Run 'package-manager sync' to use latest available version"
}

cmd_lock() {
    _check_yq_dependency || return 1

    ui_title "ðŸ”’ Generating Package Lockfile"
    echo ""

    local timestamp=$(date -Iseconds)
    local hostname=$(hostname)

    cat > "$LOCKFILE" << EOF
# Generated: $timestamp
# Host: $hostname
# Purpose: Reproducible package versions (like NixOS flake.lock)

packages:
EOF

    ui_info "Querying installed package versions..."

    # Process pacman packages
    local pkg_count=0
    while IFS= read -r module; do
        [[ -z "$module" ]] && continue

        echo "  ${module}:" >> "$LOCKFILE"

        while IFS= read -r package; do
            # Skip flatpak packages
            if _is_flatpak "$package"; then
                continue
            fi

            local pkg_data=$(_parse_package_constraint "$package")
            IFS='|' read -r name version constraint_type <<< "$pkg_data"

            local installed_version=$(_get_package_version "$name")

            if [[ -n "$installed_version" ]]; then
                if _is_rolling_package "$name"; then
                    echo "    ${name}: \"${installed_version}\"  # rolling (-git package)" >> "$LOCKFILE"
                else
                    echo "    ${name}: \"${installed_version}\"" >> "$LOCKFILE"
                fi
                ((pkg_count++))
            fi
        done < <(_get_module_packages "$module")
    done < <(_get_enabled_modules)

    # Process flatpak packages
    echo "" >> "$LOCKFILE"
    echo "flatpaks:" >> "$LOCKFILE"

    local flatpak_count=0
    while IFS= read -r module; do
        [[ -z "$module" ]] && continue

        local has_flatpak=false
        while IFS= read -r package; do
            if _is_flatpak "$package"; then
                if [[ "$has_flatpak" == "false" ]]; then
                    echo "  ${module}:" >> "$LOCKFILE"
                    has_flatpak=true
                fi

                local app_id=$(_strip_flatpak_prefix "$package")
                local version=$(_get_flatpak_version "$app_id")

                if [[ -n "$version" ]]; then
                    echo "    ${app_id}: \"${version}\"" >> "$LOCKFILE"
                    ((flatpak_count++))
                fi
            fi
        done < <(_get_module_packages "$module")
    done < <(_get_enabled_modules)

    echo ""
    ui_success "Lockfile generated: $LOCKFILE"
    ui_info "Packages: $pkg_count | Flatpaks: $flatpak_count"
    ui_info "Commit this file to track your system's package state"
}

cmd_versions() {
    local package="$1"
    _check_yq_dependency || return 1

    if [[ -z "$package" ]]; then
        ui_error "Package name required"
        ui_info "Usage: package-manager versions <package>"
        return 1
    fi

    ui_title "ðŸ“Š Version Information: $package"
    echo ""

    # Check if it's a flatpak
    if _is_flatpak "$package"; then
        local app_id=$(_strip_flatpak_prefix "$package")

        # Installed version
        local installed=$(_get_flatpak_version "$app_id")
        if [[ -n "$installed" ]]; then
            ui_info "Installed: $installed"
        else
            ui_warning "Not installed"
        fi
    else
        # Installed version
        local installed=$(_get_package_version "$package")
        if [[ -n "$installed" ]]; then
            ui_info "Installed: $installed"
        else
            ui_warning "Not installed"
        fi

        # Available version
        local available=$(_get_repo_version "$package")
        if [[ -n "$available" ]]; then
            ui_info "Available: $available"
        fi

        # Rolling package check
        if _is_rolling_package "$package"; then
            echo ""
            ui_warning "âš ï¸  This is a -git package (rolling release)"
            ui_info "Version pinning not recommended for rolling packages"
        fi

        # Cached versions
        echo ""
        ui_info "Versions in local cache:"
        local cache_dir="/var/cache/pacman/pkg"
        local cache_found=false
        for pkg_file in ${cache_dir}/${package}-*.pkg.tar.zst; do
            if [[ -f "$pkg_file" ]]; then
                local basename=$(basename "$pkg_file")
                local version_str=$(echo "$basename" | sed "s/^${package}-//;s/-$(uname -m)\.pkg\.tar\.zst$//")
                echo "  â€¢ $version_str"
                cache_found=true
            fi
        done
        if [[ "$cache_found" == "false" ]]; then
            echo "  (none)"
        fi
    fi

    # Check for constraint in modules
    echo ""
    ui_info "Version constraint:"
    local has_constraint=false
    while IFS= read -r module; do
        [[ -z "$module" ]] && continue

        local constraint=$(yq eval ".packages.modules.${module}.packages[] | select(.name == \"$package\") | .version" "$PACKAGES_FILE" 2>/dev/null)

        if [[ -n "$constraint" && "$constraint" != "null" ]]; then
            ui_success "Pinned to: $constraint (in module '$module')"
            has_constraint=true
            break
        fi
    done < <(_get_enabled_modules)

    if [[ "$has_constraint" == "false" ]]; then
        ui_info "No constraint (will use latest available)"
    fi
}

cmd_outdated() {
    _check_yq_dependency || return 1

    ui_title "âš ï¸  Packages Violating Version Constraints"
    echo ""

    local violations=0

    while IFS= read -r module; do
        [[ -z "$module" ]] && continue

        while IFS= read -r package; do
            # Skip flatpaks
            if _is_flatpak "$package"; then
                continue
            fi

            local pkg_data=$(_parse_package_constraint "$package")
            IFS='|' read -r name version constraint_type <<< "$pkg_data"

            if [[ "$constraint_type" == "none" ]]; then
                continue
            fi

            local installed=$(_get_package_version "$name")
            if [[ -z "$installed" ]]; then
                continue
            fi

            # Check constraint violation using vercmp
            local violates=false
            case "$constraint_type" in
                "exact")
                    if [[ "$installed" != "$version" ]]; then
                        violates=true
                    fi
                    ;;
                "minimum")
                    _compare_versions "$installed" "$version"
                    local cmp=$?
                    if [[ $cmp -eq 2 ]]; then  # installed < required
                        violates=true
                    fi
                    ;;
                "maximum")
                    _compare_versions "$installed" "$version"
                    local cmp=$?
                    if [[ $cmp -eq 1 ]] || [[ $cmp -eq 0 ]]; then  # installed >= maximum
                        violates=true
                    fi
                    ;;
            esac

            if [[ "$violates" == "true" ]]; then
                local op=""
                case "$constraint_type" in
                    "exact") op="==" ;;
                    "minimum") op=">=" ;;
                    "maximum") op="<" ;;
                esac

                ui_error "$name: installed=$installed, constraint=$op$version"
                ((violations++))
            fi
        done < <(_get_module_packages "$module")
    done < <(_get_enabled_modules)

    if [[ "$violations" -eq 0 ]]; then
        ui_success "All packages meet version constraints"
        return 0
    else
        echo ""
        ui_warning "Found $violations constraint violations"
        ui_info "Run 'package-manager sync' to resolve"
        return 1
    fi
}

# =============================================================================
# SECTION 4: PACKAGE OPERATIONS
# =============================================================================

# Install a single package with constraint handling
# Usage: _install_package <package_spec> <module_name>
# package_spec: Either "package-name" or package object from YAML
_install_package() {
    local package_spec="$1"
    local module="${2:-unknown}"

    # Parse package constraint
    local pkg_data=$(_parse_package_constraint "$package_spec")
    IFS='|' read -r name version constraint_type <<< "$pkg_data"

    # Check if Flatpak package
    if [[ "$name" == flatpak:* ]]; then
        _install_flatpak "$name" "$module"
        return $?
    fi

    # Validate package exists
    if ! _check_package_exists "$name"; then
        ui_error "Package '$name' not found in repos or AUR"
        return 1
    fi

    # Warn about rolling packages
    if _is_rolling_package "$name"; then
        ui_warning "âš ï¸  '$name' is a rolling package (-git suffix)"
        if [[ -n "$version" ]]; then
            ui_warning "Version constraints may not work as expected"
        fi
    fi

    # Check if already installed with correct version
    local installed=$(_get_package_version "$name")
    if [[ -n "$installed" ]]; then
        # Already installed, check if version matches constraint
        case "$constraint_type" in
            "exact")
                if [[ "$installed" == "$version" ]]; then
                    ui_info "ðŸ“¦ $name: Already at exact version $version"
                    return 0
                else
                    ui_step "ðŸ“¦ $name: Switching from $installed to $version"
                fi
                ;;
            "minimum")
                _compare_versions "$installed" "$version"
                local cmp=$?
                if [[ $cmp -eq 1 ]] || [[ $cmp -eq 0 ]]; then
                    ui_info "ðŸ“¦ $name: Already meets constraint >=$version (installed: $installed)"
                    return 0
                else
                    ui_step "ðŸ“¦ $name: Upgrading from $installed to meet >=$version"
                fi
                ;;
            "maximum")
                _compare_versions "$installed" "$version"
                local cmp=$?
                if [[ $cmp -eq 2 ]]; then
                    ui_info "ðŸ“¦ $name: Already meets constraint <$version (installed: $installed)"
                    return 0
                else
                    ui_warning "ðŸ“¦ $name: Installed $installed violates <$version constraint"
                    ui_warning "Interactive downgrade required (use 'sync' command)"
                    return 0
                fi
                ;;
            "none")
                ui_info "ðŸ“¦ $name: Already installed ($installed)"
                return 0
                ;;
        esac
    else
        ui_step "ðŸ“¦ Installing $name${version:+ ($constraint_type $version)}"
    fi

    # Build paru command
    local install_cmd="paru -S --noconfirm --needed"

    # Add version specifier if needed
    if [[ -n "$version" ]] && [[ "$constraint_type" == "exact" ]]; then
        install_cmd="$install_cmd ${name}=${version}"
    else
        install_cmd="$install_cmd ${name}"
    fi

    # Execute installation
    if eval "$install_cmd"; then
        # Get actual installed version
        local new_version=$(_get_package_version "$name")

        # Update state file
        local constraint_value="null"
        if [[ -n "$version" ]]; then
            case "$constraint_type" in
                "exact") constraint_value="\"$version\"" ;;
                "minimum") constraint_value="\">=$version\"" ;;
                "maximum") constraint_value="\"<$version\"" ;;
            esac
        fi

        _update_package_state "$name" "$new_version" "pacman" "$module" "$constraint_value"

        ui_success "Installed $name ($new_version)"
        return 0
    else
        ui_error "Failed to install $name"
        return 1
    fi
}

# Install a Flatpak package
# Usage: _install_flatpak <flatpak_spec> <module_name>
# flatpak_spec: "flatpak:com.example.App"
_install_flatpak() {
    local package_spec="$1"
    local module="${2:-unknown}"

    # Strip "flatpak:" prefix
    local flatpak_id="${package_spec#flatpak:}"

    # Check if already installed
    if flatpak list --app --columns=application 2>/dev/null | grep -q "^${flatpak_id}$"; then
        local installed_version=$(flatpak list --app --columns=application,version 2>/dev/null | grep "^${flatpak_id}" | awk '{print $2}')
        ui_info "ðŸ“¦ $flatpak_id: Already installed${installed_version:+ ($installed_version)}"
        return 0
    fi

    ui_step "ðŸ“¦ Installing Flatpak: $flatpak_id"

    # Install with --user scope (ALWAYS user scope, never system)
    if flatpak install -y --user flathub "$flatpak_id" 2>&1; then
        local version=$(flatpak list --app --columns=application,version 2>/dev/null | grep "^${flatpak_id}" | awk '{print $2}')

        # Update state file
        _update_package_state "$flatpak_id" "${version:-unknown}" "flatpak" "$module" "null"

        ui_success "Installed Flatpak: $flatpak_id${version:+ ($version)}"
        return 0
    else
        ui_error "Failed to install Flatpak: $flatpak_id"
        return 1
    fi
}

# Remove a package (pacman or flatpak)
# Usage: _remove_package <package_name>
_remove_package() {
    local package="$1"

    # Check if package is in state file
    local pkg_type=$(yq eval ".packages[] | select(.name == \"$package\") | .type" "$STATE_FILE" 2>/dev/null)

    if [[ -z "$pkg_type" ]]; then
        # Not in state file, try to detect
        if pacman -Q "$package" &>/dev/null; then
            pkg_type="pacman"
        elif flatpak list --app --columns=application 2>/dev/null | grep -q "^${package}$"; then
            pkg_type="flatpak"
        else
            ui_warning "Package '$package' not found (not installed or not in state)"
            return 1
        fi
    fi

    # Check if pinned
    local is_pinned=$(yq eval ".packages[] | select(.name == \"$package\") | .pinned" "$STATE_FILE" 2>/dev/null)
    if [[ "$is_pinned" == "true" ]]; then
        ui_warning "âš ï¸  Package '$package' is pinned"
        if ! ui_confirm "Remove anyway?"; then
            ui_info "Cancelled"
            return 0
        fi
    fi

    ui_step "ðŸ—‘ï¸  Removing $package ($pkg_type)"

    # Remove based on type
    case "$pkg_type" in
        "pacman")
            if paru -R --noconfirm "$package"; then
                ui_success "Removed $package"
            else
                ui_error "Failed to remove $package"
                return 1
            fi
            ;;
        "flatpak")
            if flatpak uninstall -y --user "$package" 2>&1; then
                ui_success "Removed Flatpak: $package"
            else
                ui_error "Failed to remove Flatpak: $package"
                return 1
            fi
            ;;
        *)
            ui_error "Unknown package type: $pkg_type"
            return 1
            ;;
    esac

    # Remove from state file
    yq eval "del(.packages[] | select(.name == \"$package\"))" -i "$STATE_FILE"

    return 0
}

# Interactive downgrade version selection
# Usage: version=$(_select_downgrade_version <package_name>)
# Returns: Selected version string, or empty if cancelled
_select_downgrade_version() {
    local package="$1"

    ui_step "Fetching available versions for $package..."

    # Get available versions from paru (AUR and repos)
    local versions=$(paru -Si "$package" 2>/dev/null | grep -E '^Version' | awk '{print $3}' | head -20)

    if [[ -z "$versions" ]]; then
        ui_error "No versions found for $package"
        return 1
    fi

    # Build numbered menu
    ui_info "Available versions for $package:"
    echo ""

    local -a version_array=()
    local i=1
    while IFS= read -r ver; do
        ui_info "  [$i] $ver"
        version_array+=("$ver")
        ((i++))
    done <<< "$versions"

    ui_info "  [q] Cancel"
    ui_spacer

    # Get user selection
    local selection
    while true; do
        read -p "Select version (1-${#version_array[@]}, or 'q' to cancel): " selection

        if [[ "$selection" == "q" ]] || [[ "$selection" == "Q" ]]; then
            return 1
        fi

        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le "${#version_array[@]}" ]]; then
            local selected_version="${version_array[$((selection - 1))]}"
            echo "$selected_version"
            return 0
        else
            ui_warning "Invalid selection, try again"
        fi
    done
}

# Command: Install a package
# Usage: package-manager install <package>
cmd_install() {
    if [[ $# -eq 0 ]]; then
        ui_error "Usage: package-manager install <package>"
        return 1
    fi

    local package="$1"

    _install_package "$package" "manual"
}

# Command: Remove a package
# Usage: package-manager remove <package>
cmd_remove() {
    if [[ $# -eq 0 ]]; then
        ui_error "Usage: package-manager remove <package>"
        return 1
    fi

    local package="$1"

    _remove_package "$package"
}

# Command: Merge unmanaged packages into modules
# Usage: package-manager merge [--dry-run]
cmd_merge() {
    local dry_run=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run|-n)
                dry_run=true
                shift
                ;;
            *)
                ui_error "Unknown flag: $1"
                ui_info "Usage: package-manager merge [--dry-run]"
                return 1
                ;;
        esac
    done

    _check_yq_dependency || return 1

    ui_title "ðŸ“¦ Merge Unmanaged Packages"
    echo ""

    ui_step "Scanning explicitly installed packages..."
    local installed_packages=$(pacman -Qeq 2>/dev/null)
    local installed_count=$(echo "$installed_packages" | wc -l)
    ui_info "Found $installed_count explicitly installed packages"

    ui_step "Loading declared packages from modules..."
    local -a declared_packages=()

    while IFS= read -r module; do
        [[ -z "$module" ]] && continue

        while IFS= read -r package; do
            local pkg_data=$(_parse_package_constraint "$package")
            IFS='|' read -r name version constraint_type <<< "$pkg_data"

            # Strip flatpak: prefix for comparison
            local name_stripped="${name#flatpak:}"
            declared_packages+=("$name_stripped")
        done < <(_get_module_packages "$module")
    done < <(_get_modules)

    ui_info "Found ${#declared_packages[@]} declared packages across all modules"

    # Find unmanaged packages
    ui_step "Identifying unmanaged packages..."
    local -a unmanaged=()

    while IFS= read -r pkg; do
        [[ -z "$pkg" ]] && continue

        local found=false
        for declared in "${declared_packages[@]}"; do
            if [[ "$declared" == "$pkg" ]]; then
                found=true
                break
            fi
        done

        if [[ "$found" == "false" ]]; then
            unmanaged+=("$pkg")
        fi
    done <<< "$installed_packages"

    echo ""

    if [[ ${#unmanaged[@]} -eq 0 ]]; then
        ui_success "All explicitly installed packages are already managed!"
        return 0
    fi

    ui_warning "Found ${#unmanaged[@]} unmanaged packages:"
    echo ""

    for pkg in "${unmanaged[@]}"; do
        ui_info "  â€¢ $pkg"
    done

    echo ""

    if [[ "$dry_run" == "true" ]]; then
        ui_info "Dry run mode - no changes will be made"
        return 0
    fi

    # Interactive module selection
    if ! ui_confirm "Add these packages to a module?"; then
        ui_info "Cancelled"
        return 0
    fi

    # Get list of modules for selection
    local -a module_list=()
    while IFS= read -r module; do
        [[ -z "$module" ]] && continue
        module_list+=("$module")
    done < <(_get_modules)

    if [[ ${#module_list[@]} -eq 0 ]]; then
        ui_error "No modules found in packages.yaml"
        return 1
    fi

    # Display module options
    ui_info "Available modules:"
    echo ""
    local i=1
    for module in "${module_list[@]}"; do
        local description=$(yq eval ".packages.modules.${module}.description" "$PACKAGES_FILE" 2>/dev/null)
        [[ -z "$description" || "$description" == "null" ]] && description="No description"
        ui_info "  [$i] $module"
        ui_info "      $description"
        ((i++))
    done

    echo ""

    # Get user selection
    local selection
    while true; do
        read -p "Select module (1-${#module_list[@]}, or 'q' to cancel): " selection

        if [[ "$selection" == "q" ]] || [[ "$selection" == "Q" ]]; then
            ui_info "Cancelled"
            return 0
        fi

        if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le "${#module_list[@]}" ]]; then
            break
        else
            ui_warning "Invalid selection, try again"
        fi
    done

    local selected_module="${module_list[$((selection - 1))]}"
    echo ""
    ui_step "Adding packages to module: $selected_module"

    # Add packages to selected module
    local added=0
    for pkg in "${unmanaged[@]}"; do
        yq eval ".packages.modules.${selected_module}.packages += [\"$pkg\"]" -i "$PACKAGES_FILE"
        ((added++))
    done

    echo ""
    ui_success "Added $added packages to module '$selected_module'"
    ui_info "Run 'package-manager sync' to reconcile system state"
}

# =============================================================================
# SECTION 5: ENHANCED SYNC
# =============================================================================

# Detect available backup tool (timeshift or snapper)
# Returns: Tool name or empty string if none available
_get_backup_tool() {
    # Check for explicit preference in packages.yaml
    local configured=$(yq eval '.backup_tool // ""' "$PACKAGES_FILE" 2>/dev/null)

    if [[ -n "$configured" ]] && [[ "$configured" != "null" ]]; then
        if command -v "$configured" >/dev/null 2>&1; then
            echo "$configured"
            return
        fi
    fi

    # Auto-detect: prefer timeshift, fallback to snapper
    if command -v timeshift >/dev/null 2>&1; then
        echo "timeshift"
    elif command -v snapper >/dev/null 2>&1; then
        echo "snapper"
    else
        echo ""
    fi
}

# Get snapper config name from packages.yaml (default: root)
_get_snapper_config() {
    local snapper_config=$(yq eval '.snapper_config // "root"' "$PACKAGES_FILE" 2>/dev/null)
    echo "$snapper_config"
}

# Create optional backup before sync (supports timeshift and snapper)
# Usage: _create_backup
# Returns: 0 on success or skip, 1 on failure (non-fatal)
_create_backup() {
    local backup_tool=$(_get_backup_tool)

    # No backup tool available
    if [[ -z "$backup_tool" ]]; then
        return 0  # Skip silently if not installed
    fi

    ui_info "$backup_tool backup available"

    if ui_confirm "Create system backup before sync?"; then
        ui_step "Creating $backup_tool backup..."

        local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
        local comment="package-manager sync - $timestamp"

        case "$backup_tool" in
            timeshift)
                if sudo timeshift --create --comments "$comment" --scripted; then
                    ui_success "Timeshift backup created successfully"
                    return 0
                else
                    ui_warning "Timeshift backup failed (continuing anyway)"
                    return 1
                fi
                ;;
            snapper)
                local snapper_config=$(_get_snapper_config)
                if sudo snapper -c "$snapper_config" create -d "$comment"; then
                    ui_success "Snapper snapshot created successfully (config: $snapper_config)"
                    return 0
                else
                    ui_warning "Snapper snapshot failed (continuing anyway)"
                    return 1
                fi
                ;;
            *)
                ui_warning "Unknown backup tool: $backup_tool"
                return 1
                ;;
        esac
    else
        ui_info "Skipping backup"
        return 0
    fi
}

# Command: Sync system to packages.yaml state
# Usage: package-manager sync [--prune]
cmd_sync() {
    local prune=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --prune)
                prune=true
                shift
                ;;
            *)
                ui_error "Unknown flag: $1"
                ui_info "Usage: package-manager sync [--prune]"
                return 1
                ;;
        esac
    done

    ui_title "ðŸ“¦ Syncing System to packages.yaml"

    # Optional backup (timeshift or snapper)
    _create_backup

    # Initialize counters
    local total=0
    local installed=0
    local upgraded=0
    local downgraded=0
    local skipped=0
    local failed=0

    # Collect all packages from enabled modules
    local -a pacman_packages=()
    local -a flatpak_packages=()

    ui_step "Collecting packages from enabled modules..."

    while IFS= read -r module; do
        ui_info "  â€¢ $module"

        while IFS= read -r package; do
            ((total++))

            # Parse package to extract name
            local pkg_data=$(_parse_package_constraint "$package")
            IFS='|' read -r name version constraint_type <<< "$pkg_data"

            # Categorize by type
            if [[ "$name" == flatpak:* ]]; then
                flatpak_packages+=("$package|$module")
            else
                pacman_packages+=("$package|$module")
            fi
        done < <(_get_module_packages "$module")
    done < <(_get_enabled_modules)

    ui_success "Found $total packages (${#pacman_packages[@]} pacman, ${#flatpak_packages[@]} flatpak)"

    # Batch validate pacman packages (if any)
    if [[ ${#pacman_packages[@]} -gt 0 ]]; then
        ui_step "Validating pacman packages..."

        local -a pkg_names=()
        for pkg_entry in "${pacman_packages[@]}"; do
            local package="${pkg_entry%%|*}"
            local pkg_data=$(_parse_package_constraint "$package")
            IFS='|' read -r name version constraint_type <<< "$pkg_data"
            pkg_names+=("$name")
        done

        local invalid=$(_check_packages_batch "${pkg_names[@]}")
        if [[ -n "$invalid" ]]; then
            ui_error "Invalid packages found:"
            echo "$invalid" | while IFS= read -r pkg; do
                ui_error "  â€¢ $pkg"
            done
            ui_warning "Fix packages.yaml before continuing"
            return 1
        fi

        ui_success "All packages valid"
    fi

    # Cache installed package versions (performance optimization)
    ui_step "Caching installed package versions..."
    declare -A installed_versions_map
    while IFS=' ' read -r pkg ver; do
        installed_versions_map["$pkg"]="$ver"
    done < <(pacman -Q 2>/dev/null | awk '{print $1, $2}')
    ui_info "Cached ${#installed_versions_map[@]} package versions"

    # Process pacman packages
    if [[ ${#pacman_packages[@]} -gt 0 ]]; then
        ui_step "Processing pacman packages..."

        for pkg_entry in "${pacman_packages[@]}"; do
            IFS='|' read -r package module <<< "$pkg_entry"

            # Parse constraint
            local pkg_data=$(_parse_package_constraint "$package")
            IFS='|' read -r name version constraint_type <<< "$pkg_data"

            # Check current installation (use cached version)
            local installed_version="${installed_versions_map[$name]:-}"

            if [[ -z "$installed_version" ]]; then
                # Not installed, install it
                ui_step "ðŸ“¦ $name: Installing${version:+ ($constraint_type $version)}"

                if _install_package "$package" "$module"; then
                    ((installed++))
                else
                    ((failed++))
                fi
                continue
            fi

            # Already installed, check constraints
            case "$constraint_type" in
                "exact")
                    if [[ "$installed_version" == "$version" ]]; then
                        ui_info "ðŸ“¦ $name: OK (exact $version)"
                        continue
                    else
                        ui_step "ðŸ“¦ $name: Switching $installed_version â†’ $version"

                        if _install_package "$package" "$module"; then
                            ((upgraded++))
                        else
                            ((failed++))
                        fi
                    fi
                    ;;

                "minimum")
                    _compare_versions "$installed_version" "$version"
                    local cmp=$?

                    if [[ $cmp -eq 1 ]] || [[ $cmp -eq 0 ]]; then
                        # installed >= required
                        ui_info "ðŸ“¦ $name: OK (>=$version, have $installed_version)"
                        continue
                    else
                        # installed < required, upgrade
                        ui_step "ðŸ“¦ $name: Upgrading $installed_version â†’ >=$version"

                        if _install_package "$package" "$module"; then
                            ((upgraded++))
                        else
                            ((failed++))
                        fi
                    fi
                    ;;

                "maximum")
                    _compare_versions "$installed_version" "$version"
                    local cmp=$?

                    if [[ $cmp -eq 2 ]]; then
                        # installed < maximum, OK
                        ui_info "ðŸ“¦ $name: OK (<$version, have $installed_version)"
                        continue
                    else
                        # installed >= maximum, need downgrade
                        ui_warning "ðŸ“¦ $name: Installed $installed_version violates <$version constraint"

                        if ui_confirm "Interactive downgrade for $name?"; then
                            local selected_version=$(_select_downgrade_version "$name")

                            if [[ -n "$selected_version" ]]; then
                                # Validate selected version meets constraint
                                _compare_versions "$selected_version" "$version"
                                local ver_cmp=$?

                                if [[ $ver_cmp -eq 2 ]]; then
                                    ui_step "ðŸ“¦ $name: Downgrading $installed_version â†’ $selected_version"

                                    if paru -S --noconfirm "${name}=${selected_version}"; then
                                        _update_package_state "$name" "$selected_version" "pacman" "$module" "\"<$version\""
                                        ui_success "Downgraded $name to $selected_version"
                                        ((downgraded++))
                                    else
                                        ui_error "Failed to downgrade $name"
                                        ((failed++))
                                    fi
                                else
                                    ui_error "Selected version $selected_version does not meet <$version constraint"
                                    ((skipped++))
                                fi
                            else
                                ui_info "Downgrade cancelled"
                                ((skipped++))
                            fi
                        else
                            ui_info "Skipped downgrade"
                            ((skipped++))
                        fi
                    fi
                    ;;

                "none")
                    # No constraint, just ensure installed
                    ui_info "ðŸ“¦ $name: OK ($installed_version)"
                    ;;
            esac
        done
    fi

    # Process flatpak packages
    if [[ ${#flatpak_packages[@]} -gt 0 ]]; then
        ui_step "Processing flatpak packages..."

        for pkg_entry in "${flatpak_packages[@]}"; do
            IFS='|' read -r package module <<< "$pkg_entry"

            # Parse name
            local pkg_data=$(_parse_package_constraint "$package")
            IFS='|' read -r name version constraint_type <<< "$pkg_data"

            # Strip flatpak: prefix for checking
            local flatpak_id="${name#flatpak:}"

            # Check if installed
            if flatpak list --app --columns=application 2>/dev/null | grep -q "^${flatpak_id}$"; then
                ui_info "ðŸ“¦ $flatpak_id: OK"
                continue
            else
                ui_step "ðŸ“¦ $flatpak_id: Installing"

                if _install_flatpak "$name" "$module"; then
                    ((installed++))
                else
                    ((failed++))
                fi
            fi
        done
    fi

    # Prune orphaned packages (if --prune flag)
    if [[ "$prune" == "true" ]]; then
        ui_step "Checking for orphaned packages (not in any enabled module)..."

        local -a orphans=()

        # Get all installed packages from state file
        while IFS= read -r pkg_name; do
            local found=false

            # Check if package exists in any enabled module
            while IFS= read -r module; do
                while IFS= read -r package; do
                    local pkg_data=$(_parse_package_constraint "$package")
                    IFS='|' read -r name version constraint_type <<< "$pkg_data"

                    # Strip flatpak: prefix from packages.yaml for comparison
                    # State file stores Flatpak packages without prefix (e.g., com.spotify.Client)
                    # packages.yaml has prefix (e.g., flatpak:com.spotify.Client)
                    local name_stripped="${name#flatpak:}"

                    if [[ "$name_stripped" == "$pkg_name" ]]; then
                        found=true
                        break 2
                    fi
                done < <(_get_module_packages "$module")
            done < <(_get_enabled_modules)

            if [[ "$found" == "false" ]]; then
                orphans+=("$pkg_name")
            fi
        done < <(yq eval '.packages[].name' "$STATE_FILE" 2>/dev/null)

        if [[ ${#orphans[@]} -gt 0 ]]; then
            ui_warning "Found ${#orphans[@]} orphaned packages:"
            for orphan in "${orphans[@]}"; do
                ui_info "  â€¢ $orphan"
            done

            if ui_confirm "Remove orphaned packages?"; then
                local removed=0
                for orphan in "${orphans[@]}"; do
                    if _remove_package "$orphan"; then
                        ((removed++))
                    fi
                done

                ui_success "Removed $removed orphaned packages"
            else
                ui_info "Skipped orphan removal"
            fi
        else
            ui_success "No orphaned packages found"
        fi
    fi

    # Final summary
    ui_title "ðŸ“Š Sync Summary"
    ui_info "  Total packages: $total"
    [[ $installed -gt 0 ]] && ui_success "  Installed: $installed" || ui_info "  Installed: $installed"
    [[ $upgraded -gt 0 ]] && ui_success "  Upgraded: $upgraded" || ui_info "  Upgraded: $upgraded"
    [[ $downgraded -gt 0 ]] && ui_success "  Downgraded: $downgraded" || ui_info "  Downgraded: $downgraded"
    [[ $skipped -gt 0 ]] && ui_warning "  Skipped: $skipped" || ui_info "  Skipped: $skipped"
    [[ $failed -gt 0 ]] && ui_error "  Failed: $failed" || ui_info "  Failed: $failed"

    if [[ $failed -eq 0 ]]; then
        ui_success "Sync complete!"
        return 0
    else
        ui_warning "Sync complete with $failed failures"
        return 1
    fi
}

# =============================================================================
# SECTION 6: STATUS & VALIDATION
# =============================================================================

# Command: Show comprehensive system status
# Usage: package-manager status
cmd_status() {
    ui_title "ðŸ“Š Package Manager Status"

    # Module Status
    ui_step "Modules"
    local total_modules=$(yq eval '.packages.modules | keys | length' "$PACKAGES_FILE")
    local enabled_count=0
    local disabled_count=0

    while IFS= read -r module; do
        ((enabled_count++))
        local pkg_count=$(_get_module_packages "$module" | wc -l)
        local description=$(yq eval ".packages.modules.${module}.description" "$PACKAGES_FILE")

        ui_success "  âœ“ $module ($pkg_count packages)"
        ui_info "    $description"

        # Check for conflicts
        local conflicts=$(_get_module_conflicts "$module")
        if [[ -n "$conflicts" ]]; then
            ui_warning "    âš ï¸  Conflicts: $conflicts"
        fi
    done < <(_get_enabled_modules)

    local disabled_modules=$(yq eval '.packages.modules | to_entries | .[] | select(.value.enabled == false) | .key' "$PACKAGES_FILE" 2>/dev/null)
    if [[ -n "$disabled_modules" ]]; then
        echo ""
        ui_info "Disabled modules:"
        while IFS= read -r module; do
            ((disabled_count++))
            ui_info "  âœ— $module" | ui_color gray
        done <<< "$disabled_modules"
    fi

    echo ""
    ui_success "Total: $total_modules modules ($enabled_count enabled, $disabled_count disabled)"

    # Version Constraints
    echo ""
    ui_step "Version Constraints"

    local pinned_count=0
    local violations=0

    while IFS= read -r module; do
        while IFS= read -r package; do
            local pkg_data=$(_parse_package_constraint "$package")
            IFS='|' read -r name version constraint_type <<< "$pkg_data"

            if [[ "$constraint_type" != "none" ]]; then
                ((pinned_count++))

                local installed=$(_get_package_version "$name")
                local status="â“"
                local violates=false

                if [[ -n "$installed" ]]; then
                    case "$constraint_type" in
                        "exact")
                            if [[ "$installed" == "$version" ]]; then
                                status="âœ“"
                            else
                                status="âŒ"
                                violates=true
                            fi
                            ;;
                        "minimum")
                            _compare_versions "$installed" "$version"
                            local cmp=$?
                            if [[ $cmp -eq 1 ]] || [[ $cmp -eq 0 ]]; then
                                status="âœ“"
                            else
                                status="âŒ"
                                violates=true
                            fi
                            ;;
                        "maximum")
                            _compare_versions "$installed" "$version"
                            local cmp=$?
                            if [[ $cmp -eq 2 ]]; then
                                status="âœ“"
                            else
                                status="âŒ"
                                violates=true
                            fi
                            ;;
                    esac

                    if [[ "$violates" == "true" ]]; then
                        ((violations++))
                        ui_error "  $status $name: $constraint_type $version (have: $installed)"
                    else
                        ui_success "  $status $name: $constraint_type $version"
                    fi
                else
                    ui_warning "  â“ $name: $constraint_type $version (not installed)"
                fi
            fi
        done < <(_get_module_packages "$module")
    done < <(_get_enabled_modules)

    if [[ $pinned_count -eq 0 ]]; then
        ui_info "  No version constraints set"
    else
        echo ""
        if [[ $violations -eq 0 ]]; then
            ui_success "$pinned_count constraints (all satisfied)"
        else
            ui_warning "$pinned_count constraints ($violations violations)"
        fi
    fi

    # Package Health
    echo ""
    ui_step "Package Health"

    local pacman_count=$(pacman -Q 2>/dev/null | wc -l)
    local flatpak_count=$(flatpak list --app 2>/dev/null | wc -l)
    local state_count=$(yq eval '.packages | length' "$STATE_FILE" 2>/dev/null || echo 0)

    ui_info "  â€¢ Pacman: $pacman_count packages"
    ui_info "  â€¢ Flatpak: $flatpak_count packages"
    ui_info "  â€¢ State file: $state_count tracked"

    # Orphaned packages
    local orphan_count=0
    while IFS= read -r pkg_name; do
        local found=false
        while IFS= read -r module; do
            while IFS= read -r package; do
                local pkg_data=$(_parse_package_constraint "$package")
                IFS='|' read -r name version constraint_type <<< "$pkg_data"
                if [[ "$name" == "$pkg_name" ]]; then
                    found=true
                    break 2
                fi
            done < <(_get_module_packages "$module")
        done < <(_get_enabled_modules)

        if [[ "$found" == "false" ]]; then
            ((orphan_count++))
        fi
    done < <(yq eval '.packages[].name' "$STATE_FILE" 2>/dev/null)

    if [[ $orphan_count -gt 0 ]]; then
        ui_warning "  âš ï¸  Orphans: $orphan_count packages (use 'sync --prune')"
    else
        ui_success "  âœ“ No orphaned packages"
    fi

    # Rolling packages
    local rolling_count=0
    while IFS= read -r module; do
        while IFS= read -r package; do
            local pkg_data=$(_parse_package_constraint "$package")
            IFS='|' read -r name version constraint_type <<< "$pkg_data"

            if _is_rolling_package "$name"; then
                ((rolling_count++))
            fi
        done < <(_get_module_packages "$module")
    done < <(_get_enabled_modules)

    ui_info "  â€¢ Rolling packages: $rolling_count (-git suffix)"

    # State File Info
    echo ""
    ui_step "State Files"

    if [[ -f "$STATE_FILE" ]]; then
        local state_size=$(du -h "$STATE_FILE" | awk '{print $1}')
        local last_modified=$(stat -c %y "$STATE_FILE" | cut -d' ' -f1,2 | cut -d'.' -f1)
        ui_success "  âœ“ State file: $state_size (last modified: $last_modified)"
    else
        ui_error "  âŒ State file: Not found"
    fi

    if [[ -f "$LOCKFILE" ]]; then
        local lock_size=$(du -h "$LOCKFILE" | awk '{print $1}')
        ui_success "  âœ“ Lockfile: $lock_size"
    else
        ui_warning "  âš ï¸  Lockfile: Not found (run 'lock' to create)"
    fi

    echo ""
    ui_success "Status check complete"
}

# Command: Validate packages.yaml configuration
# Usage: package-manager validate [--check-packages]
cmd_validate() {
    local check_packages=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --check-packages)
                check_packages=true
                shift
                ;;
            *)
                ui_error "Unknown flag: $1"
                ui_info "Usage: package-manager validate [--check-packages]"
                return 1
                ;;
        esac
    done

    ui_title "ðŸ” Validating packages.yaml"

    local errors=0
    local warnings=0

    # 1. YAML Syntax
    ui_step "Checking YAML syntax..."
    if ! yq eval '.' "$PACKAGES_FILE" >/dev/null 2>&1; then
        ui_error "Invalid YAML syntax"
        ((errors++))
    else
        ui_success "YAML syntax valid"
    fi

    # 2. Module Structure
    ui_step "Validating module structure..."

    while IFS= read -r module; do
        # Check required fields
        local has_enabled=$(yq eval ".packages.modules.${module} | has(\"enabled\")" "$PACKAGES_FILE")
        local has_description=$(yq eval ".packages.modules.${module} | has(\"description\")" "$PACKAGES_FILE")
        local has_packages=$(yq eval ".packages.modules.${module} | has(\"packages\")" "$PACKAGES_FILE")

        if [[ "$has_enabled" != "true" ]]; then
            ui_error "Module '$module': Missing 'enabled' field"
            ((errors++))
        else
            local enabled_value=$(yq eval ".packages.modules.${module}.enabled" "$PACKAGES_FILE")
            if [[ "$enabled_value" != "true" ]] && [[ "$enabled_value" != "false" ]]; then
                ui_error "Module '$module': 'enabled' must be boolean (true/false)"
                ((errors++))
            fi
        fi

        if [[ "$has_description" != "true" ]]; then
            ui_warning "Module '$module': Missing 'description' field"
            ((warnings++))
        fi

        if [[ "$has_packages" != "true" ]]; then
            ui_error "Module '$module': Missing 'packages' field"
            ((errors++))
        else
            local pkg_count=$(_get_module_packages "$module" | wc -l)
            if [[ $pkg_count -eq 0 ]]; then
                ui_warning "Module '$module': Empty package list"
                ((warnings++))
            fi
        fi
    done < <(_get_modules)

    if [[ $errors -eq 0 ]] && [[ $warnings -eq 0 ]]; then
        ui_success "Module structure valid"
    fi

    # 3. Package Format
    ui_step "Validating package format..."

    local format_errors=0
    while IFS= read -r module; do
        while IFS= read -r package; do
            # Try to parse constraint
            local pkg_data=$(_parse_package_constraint "$package")
            IFS='|' read -r name version constraint_type <<< "$pkg_data"

            # Check for invalid characters in name
            if [[ "$name" =~ [[:space:]] ]]; then
                ui_error "Module '$module': Package name contains spaces: '$name'"
                ((format_errors++))
            fi

            # Validate constraint syntax
            if [[ -n "$version" ]]; then
                case "$constraint_type" in
                    "exact"|"minimum"|"maximum")
                        # Valid
                        ;;
                    *)
                        ui_error "Module '$module': Invalid constraint type for '$name': $constraint_type"
                        ((format_errors++))
                        ;;
                esac
            fi
        done < <(_get_module_packages "$module")
    done < <(_get_modules)

    if [[ $format_errors -eq 0 ]]; then
        ui_success "Package format valid"
    else
        ((errors += format_errors))
    fi

    # 4. Conflict Detection
    ui_step "Checking module conflicts..."

    local conflict_errors=0
    while IFS= read -r module; do
        local conflicts=$(_get_module_conflicts "$module")

        if [[ -n "$conflicts" ]]; then
            while IFS= read -r conflict; do
                # Check if conflict module exists
                if ! _get_modules | grep -q "^${conflict}$"; then
                    ui_error "Module '$module': Conflict references non-existent module '$conflict'"
                    ((conflict_errors++))
                fi

                # Check if both modules are enabled
                if _is_module_enabled "$module" && _is_module_enabled "$conflict"; then
                    ui_error "Conflict violation: Both '$module' and '$conflict' are enabled"
                    ((conflict_errors++))
                fi

                # Check for circular conflicts
                local reverse_conflicts=$(_get_module_conflicts "$conflict")
                if echo "$reverse_conflicts" | grep -q "^${module}$"; then
                    # This is expected, not an error
                    :
                fi
            done <<< "$conflicts"
        fi
    done < <(_get_modules)

    if [[ $conflict_errors -eq 0 ]]; then
        ui_success "No conflict violations"
    else
        ((errors += conflict_errors))
    fi

    # 5. Duplicate Detection
    ui_step "Checking for duplicate packages..."

    local -A pkg_locations
    local dup_errors=0

    while IFS= read -r module; do
        while IFS= read -r package; do
            local pkg_data=$(_parse_package_constraint "$package")
            IFS='|' read -r name version constraint_type <<< "$pkg_data"

            if [[ -n "${pkg_locations[$name]}" ]]; then
                ui_error "Duplicate package '$name' in modules: ${pkg_locations[$name]} and $module"
                ((dup_errors++))
            else
                pkg_locations["$name"]="$module"
            fi
        done < <(_get_module_packages "$module")
    done < <(_get_modules)

    if [[ $dup_errors -eq 0 ]]; then
        ui_success "No duplicate packages"
    else
        ((errors += dup_errors))
    fi

    # 6. Package Existence (if --check-packages)
    if [[ "$check_packages" == "true" ]]; then
        ui_step "Checking package existence (this may take a while)..."

        local -a all_packages=()
        while IFS= read -r module; do
            while IFS= read -r package; do
                local pkg_data=$(_parse_package_constraint "$package")
                IFS='|' read -r name version constraint_type <<< "$pkg_data"

                # Skip flatpak packages for now
                if [[ "$name" != flatpak:* ]]; then
                    all_packages+=("$name")
                fi
            done < <(_get_module_packages "$module")
        done < <(_get_enabled_modules)

        local invalid=$(_check_packages_batch "${all_packages[@]}")
        if [[ -n "$invalid" ]]; then
            ui_error "Invalid packages found:"
            echo "$invalid" | while IFS= read -r pkg; do
                ui_error "  â€¢ $pkg"
            done
            ((errors++))
        else
            ui_success "All packages exist in repos/AUR"
        fi
    fi

    # Final Summary
    echo ""
    ui_title "Validation Summary"
    [[ $errors -gt 0 ]] && ui_error "  Errors: $errors" || ui_info "  Errors: $errors"
    [[ $warnings -gt 0 ]] && ui_warning "  Warnings: $warnings" || ui_info "  Warnings: $warnings"

    if [[ $errors -eq 0 ]]; then
        ui_success "Validation passed!"
        return 0
    else
        ui_error "Validation failed with $errors errors"
        return 1
    fi
}

# =============================================================================
# SECTION 7: HELP & VERSION
# =============================================================================

show_help() {
    cat << 'EOF'
Package Manager v2.1.0
Module-based declarative package management with version pinning

USAGE:
    package-manager <command> [options] [arguments]

MODULE MANAGEMENT:
    module list                      List all modules with status
    module enable <module>...        Enable one or more modules
    module enable                    Interactive module selection
    module disable <module>...       Disable one or more modules
    module disable                   Interactive module selection

VERSION PINNING:
    pin <package> <version>          Pin package to specific version
                                     Examples: pin firefox 120.0
                                               pin neovim ">=0.9.0"
                                               pin python "<3.12"
    unpin <package>                  Remove version constraint
    lock                             Generate lockfile with current versions
    versions [package]               Show version info for package(s)
    outdated                         List packages violating constraints

PACKAGE OPERATIONS:
    install <package>                Install a single package
    remove <package>                 Remove a package
    merge [--dry-run]                Add unmanaged packages to modules
    sync                             Sync system to packages.yaml state
    sync --prune                     Sync + remove orphaned packages

STATUS & VALIDATION:
    status                           Show comprehensive system status
    validate                         Validate packages.yaml structure
    validate --check-packages        Validate + check package existence

LEGACY COMMANDS:
    health                           Check package system health
    update-strategy                  Update package installation strategies

VERSION CONSTRAINT SYNTAX:
    Exact version:     { name: "firefox", version: "120.0" }
    Minimum version:   { name: "neovim", version: ">=0.9.0" }
    Maximum version:   { name: "python", version: "<3.12" }

EXAMPLES:
    # Enable multiple modules
    package-manager module enable base shell_environment

    # Discover and add unmanaged packages
    package-manager merge --dry-run
    package-manager merge

    # Pin package to specific version
    package-manager pin firefox 120.0

    # Sync with constraint-aware installation
    package-manager sync

    # Check system status
    package-manager status

    # Validate configuration
    package-manager validate --check-packages

FEATURES:
    â€¢ Module system with conflict detection
    â€¢ NixOS-style version constraints (exact, >=, <)
    â€¢ Unmanaged package discovery and onboarding
    â€¢ Lockfile generation for reproducibility
    â€¢ Interactive downgrade selection
    â€¢ Rolling package detection (-git packages)
    â€¢ Batch package validation with timeout
    â€¢ Backup integration (Timeshift or Snapper)
    â€¢ Performance-optimized sync operations
    â€¢ Comprehensive validation and status checks

STATE FILES:
    Config:    ~/.local/share/chezmoi/.chezmoidata/packages.yaml
    State:     ~/.local/state/package-manager/package-state.yaml
    Lockfile:  ~/.local/state/package-manager/locked-versions.yaml

BACKUP TOOL CONFIGURATION (optional in packages.yaml):
    backup_tool: "timeshift"         # or "snapper" (auto-detects if not set)
    snapper_config: "root"           # snapper config name (default: "root")

For more information, see the CLAUDE.md documentation.
EOF
}

show_version() {
    ui_title "package-manager v2.1.0"
    ui_info "Module-based package management for Arch Linux"
}

# =============================================================================
# LEGACY FUNCTIONS (PRESERVED FOR COMPATIBILITY)
# =============================================================================

check_health() {
    if [[ "$BRIEF" != "true" ]]; then
        ui_title "ðŸ©º Package System Health Check"
    fi

    local issues=0

    # Check essential dependencies
    if command -v yq >/dev/null 2>&1; then
        [[ "$BRIEF" != "true" ]] && ui_success "yq: Available"
    else
        ui_error "yq: Missing (required for package management)"
        ((issues++))
    fi

    if command -v pacman >/dev/null 2>&1; then
        [[ "$BRIEF" != "true" ]] && ui_success "pacman: Available"
    else
        ui_error "pacman: Missing"
        ((issues++))
    fi

    local aur_helper=$(_get_aur_helper)
    if [[ -n "$aur_helper" ]]; then
        [[ "$BRIEF" != "true" ]] && ui_success "$aur_helper: Available"
    else
        [[ "$BRIEF" != "true" ]] && ui_warning "No AUR helper (paru): AUR packages unavailable"
    fi

    # Check packages file
    if [[ -f "$PACKAGES_FILE" ]]; then
        [[ "$BRIEF" != "true" ]] && ui_success "packages.yaml: Found"

        # Validate YAML syntax
        if command -v yq >/dev/null 2>&1 && yq eval '.' "$PACKAGES_FILE" >/dev/null 2>&1; then
            [[ "$BRIEF" != "true" ]] && ui_success "packages.yaml: Valid syntax"
        else
            ui_error "packages.yaml: Invalid syntax"
            ((issues++))
        fi
    else
        ui_error "packages.yaml: Not found at $PACKAGES_FILE"
        ((issues++))
    fi

    # Summary
    if [[ "$BRIEF" == "true" ]]; then
        if [[ $issues -eq 0 ]]; then
            ui_success "Package system health: OK"
            return 0
        else
            ui_error "Package system health: $issues issues found"
            return 1
        fi
    else
        if [[ $issues -eq 0 ]]; then
            ui_success "Essential dependencies available" --before 1
            return 0
        else
            ui_error "Missing essential dependencies" --before 1
            return 1
        fi
    fi
}

update_strategy() {
    if [[ "$BRIEF" != "true" ]]; then
        ui_title "ðŸ”„ Package Update"
        ui_info "This command updates system packages using paru"
        ui_spacer
    fi

    _check_yq_dependency || return 1

    local aur_helper=$(_get_aur_helper)

    if [[ -z "$aur_helper" ]]; then
        ui_error "No AUR helper found. Install paru: paru -S paru-bin"
        return 1
    fi

    # Run standard updates
    _log_verbose "Running package updates..."
    _execute_or_dry_run "Running $aur_helper update" "$aur_helper -Syu --noconfirm" || {
        ui_error "Package update failed"
        return 1
    }

    # Validate health
    _log_verbose "Validating package system health..."

    if check_health; then
        [[ "$BRIEF" != "true" ]] && ui_success "Update completed successfully"
        return 0
    else
        ui_warning "Update completed but validation found issues"
        return 1
    fi
}


# =============================================================================
# MAIN FUNCTION AND ARGUMENT PARSING
# =============================================================================

package-manager() {
    # Initialize variables (can be overridden by environment or command line)
    VERBOSE=${PACKAGE_MANAGER_VERBOSE:-false}
    DRY_RUN=${PACKAGE_MANAGER_DRY_RUN:-false}
    BRIEF=${PACKAGE_MANAGER_BRIEF:-false}

    # Parse global options that can appear before command
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                return 0
                ;;
            --version|-V)
                show_version
                return 0
                ;;
            --verbose|-v)
                export VERBOSE="true"
                shift
                ;;
            --dry-run|-n)
                export DRY_RUN="true"
                shift
                ;;
            --brief|-b)
                export BRIEF="true"
                shift
                ;;
            *)
                # Stop parsing global options when we hit something else
                break
                ;;
        esac
    done

    # Handle commands
    if [[ $# -eq 0 ]]; then
        ui_error "No command provided"
        echo ""
        show_help
        return 1
    fi

    local command="$1"
    shift

    case "$command" in
        "module")
            local subcommand="${1:-}"
            shift 2>/dev/null || true
            case "$subcommand" in
                "list")
                    cmd_module_list
                    ;;
                "enable")
                    if [[ $# -eq 0 ]]; then
                        cmd_module_enable_interactive
                    else
                        cmd_module_enable "$@"
                    fi
                    ;;
                "disable")
                    if [[ $# -eq 0 ]]; then
                        cmd_module_disable_interactive
                    else
                        cmd_module_disable "$@"
                    fi
                    ;;
                *)
                    ui_error "Unknown module subcommand: $subcommand"
                    ui_info "Usage: package-manager module {list|enable|disable}"
                    return 1
                    ;;
            esac
            ;;
        "pin")
            cmd_pin "$@"
            ;;
        "unpin")
            cmd_unpin "$@"
            ;;
        "lock")
            cmd_lock
            ;;
        "versions")
            cmd_versions "$@"
            ;;
        "outdated")
            cmd_outdated
            ;;
        "install")
            cmd_install "$@"
            ;;
        "remove")
            cmd_remove "$@"
            ;;
        "merge")
            cmd_merge "$@"
            ;;
        "sync")
            cmd_sync "$@"
            ;;
        "status")
            cmd_status
            ;;
        "validate")
            cmd_validate "$@"
            ;;
        "health")
            check_health
            ;;
        "update-strategy")
            update_strategy
            ;;
        "help"|"-h"|"--help")
            show_help
            return 0
            ;;
        "version"|"-V"|"--version")
            show_version
            return 0
            ;;
        *)
            ui_error "Unknown command: $command"
            ui_info "Run 'package-manager --help' for usage information"
            return 1
            ;;
    esac
}

# Execute the function if script is run directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    package-manager "$@"
fi
