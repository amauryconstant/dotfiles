#!/usr/bin/env bash

# Script: state.sh
# Purpose: State file I/O for package-manager
# Requirements: yq

# =============================================================================
# STATE FILE I/O
# =============================================================================

_init_state_file() {
    if [[ ! -f "$STATE_FILE" ]]; then
        cat > "$STATE_FILE" << 'EOF'
# Package state file
# Generated by package-manager
# Tracks installed packages with metadata

packages: []
EOF
    fi
}

_read_state() {
    _init_state_file
    yq eval '.packages' "$STATE_FILE"
}

_update_package_state() {
    local name="$1"
    local version="$2"
    local type="${3:-pacman}"  # pacman or flatpak
    local module="${4:-unknown}"
    local constraint="${5:-null}"

    # Validate required inputs (NO strict mode - explicit checks)
    if [[ -z "${name:-}" ]] || [[ -z "${version:-}" ]]; then
        ui_error "CRITICAL: Missing required variables for state update"
        ui_error "name='${name:-}' version='${version:-}'"
        return 1
    fi

    # Validate type is pacman or flatpak
    if [[ "$type" != "pacman" ]] && [[ "$type" != "flatpak" ]]; then
        ui_error "CRITICAL: Invalid package type '$type' (must be 'pacman' or 'flatpak')"
        return 1
    fi

    _init_state_file

    local timestamp=$(date -Iseconds)

    # Atomic write pattern: use temp file + validation + atomic commit
    local temp_state="${STATE_FILE}.tmp.$$"
    local error_log="${STATE_FILE}.error.$$"

    # Copy current state to temp file
    if ! cp "$STATE_FILE" "$temp_state" 2>"$error_log"; then
        ui_error "CRITICAL: Failed to create temp state file"
        cat "$error_log" >&2
        rm -f "$error_log"
        return 1
    fi

    # Remove existing entry from temp file
    if ! yq eval --arg name "$name" 'del(.packages[] | select(.name == $name))' -i "$temp_state" 2>"$error_log"; then
        ui_error "CRITICAL: Failed to remove existing entry for '$name'"
        cat "$error_log" >&2
        rm -f "$temp_state" "$error_log"
        return 1
    fi

    # Prepare new entry
    local pinned="false"
    [[ "$constraint" != "null" ]] && pinned="true"

    local package_entry=$(cat <<EOF
{
  "name": "$name",
  "version": "$version",
  "type": "$type",
  "module": "$module",
  "constraint": $constraint,
  "pinned": $pinned,
  "installed_at": "$timestamp",
  "last_updated": "$timestamp"
}
EOF
)

    # Add new entry to temp file
    if ! yq eval ".packages += [$package_entry]" -i "$temp_state" 2>"$error_log"; then
        ui_error "CRITICAL: Failed to add new entry for '$name'"
        cat "$error_log" >&2
        rm -f "$temp_state" "$error_log"
        return 1
    fi

    # Validate temp file syntax before committing
    if ! yq eval '.' "$temp_state" >/dev/null 2>"$error_log"; then
        ui_error "CRITICAL: State file corrupted during update for '$name'"
        ui_error "Temp file validation failed - state file NOT updated"
        cat "$error_log" >&2
        rm -f "$temp_state" "$error_log"
        return 1
    fi

    # Atomic commit: move temp to actual (this is atomic on same filesystem)
    if ! mv "$temp_state" "$STATE_FILE" 2>"$error_log"; then
        ui_error "CRITICAL: Failed to commit state file update"
        cat "$error_log" >&2
        rm -f "$temp_state" "$error_log"
        return 1
    fi

    # Cleanup error log
    rm -f "$error_log"
    return 0
}

# Remove package from state
_remove_package_state() {
    local name="$1"

    # Validate input
    if [[ -z "${name:-}" ]]; then
        ui_error "CRITICAL: Missing package name for state removal"
        return 1
    fi

    _init_state_file

    # Atomic write pattern
    local temp_state="${STATE_FILE}.tmp.$$"
    local error_log="${STATE_FILE}.error.$$"

    # Copy current state to temp file
    if ! cp "$STATE_FILE" "$temp_state" 2>"$error_log"; then
        ui_error "CRITICAL: Failed to create temp state file for removal"
        cat "$error_log" >&2
        rm -f "$error_log"
        return 1
    fi

    # Remove entry from temp file
    if ! yq eval --arg name "$name" 'del(.packages[] | select(.name == $name))' -i "$temp_state" 2>"$error_log"; then
        ui_error "CRITICAL: Failed to remove entry for '$name'"
        cat "$error_log" >&2
        rm -f "$temp_state" "$error_log"
        return 1
    fi

    # Validate temp file
    if ! yq eval '.' "$temp_state" >/dev/null 2>"$error_log"; then
        ui_error "CRITICAL: State file corrupted during removal of '$name'"
        cat "$error_log" >&2
        rm -f "$temp_state" "$error_log"
        return 1
    fi

    # Atomic commit
    if ! mv "$temp_state" "$STATE_FILE" 2>"$error_log"; then
        ui_error "CRITICAL: Failed to commit state file after removal"
        cat "$error_log" >&2
        rm -f "$temp_state" "$error_log"
        return 1
    fi

    # Cleanup
    rm -f "$error_log"
    return 0
}

# Get package info from state
_get_package_state() {
    local name="$1"
    _init_state_file
    yq eval --arg name "$name" '.packages[] | select(.name == $name)' "$STATE_FILE"
}

# Check if package is in state
_is_package_in_state() {
    local name="$1"
    _init_state_file
    yq eval --arg name "$name" '.packages[] | select(.name == $name) | .name' "$STATE_FILE" | grep -q "^${name}$"
}
